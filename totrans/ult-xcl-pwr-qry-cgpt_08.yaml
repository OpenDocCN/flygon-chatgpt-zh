- en: '[CHAPTER 6](toc.xhtml#c06)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[XLOOKUP](toc.xhtml#c06)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Introduction](toc.xhtml#s84a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will introduce the first dynamic array lookup function —
    `**XLOOKUP**`.
  prefs: []
  type: TYPE_NORMAL
- en: When introduced in 2019, it was hailed as the “Functions Killer”, “Ultimate
    Lookup Function”, “Single Most Important function”, and so on. It was supposed
    to replace the `**LOOKUP**`, `**VLOOKUP**`, `**HLOOKUP**`, and `**INDEX**`/`**MATCH**`
    combo.
  prefs: []
  type: TYPE_NORMAL
- en: Let us now explore areas where we can use this function and what advantages
    it has over the others.
  prefs: []
  type: TYPE_NORMAL
- en: '[Structure](toc.xhtml#s85a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss the 15 reasons why `**XLOOKUP**` is a far
    better option than the previously discussed functions:'
  prefs: []
  type: TYPE_NORMAL
- en: Defaults to exact match
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easily return multiple adjacent and non-adjacent columns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easily lookup to the left or right
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easily accommodates column insertion/deletion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easily lookup vertically or horizontally
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easily lookup from the bottom up
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easily integrates wildcards in the lookup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns a cell reference
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns values in case of “No Match”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easily two-way or three-way lookup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns non-adjacent columns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns the last empty or non-empty cell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lookup non-contiguous array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easily returns duplicate lookup values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Exact match default](toc.xhtml#s86a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is the basic `**XLOOKUP**` syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '`=XLOOKUP(lookup_value, lookup_array, return_array, [match_mode], [search_mode])`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Where:'
  prefs: []
  type: TYPE_NORMAL
- en: '`**lookup_value:**` We want to search for this value in the `lookup_array`.
    It can be a cell reference or a constant value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**lookup_array:**` This is the range or array where we search the above value.
    It can be a single column or row or a two-dimensional range.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**return_array:**` This is the range or array from which we want to retrieve
    the result. It can be a single column or row or a two-dimensional range.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**match_mode (optional):**` This parameter determines how the function matches
    the `lookup_value` with the values in the `lookup_array`. It can be specified
    as 0 (exact match), -1 (exact or next smaller), 1 (exact or next larger), or 2
    (wild character match). If omitted, `**XLOOKUP**` will default to an exact match.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**search_mode (optional):**` This parameter determines the search behavior
    of the function, that is, 1 (first to last), -1 (last to first), or 2 (binary
    search). If omitted, `**XLOOKUP**` will default to 1 (first to last).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This default to an exact match makes `**XLOOKUP**` less prone to errors present
    when using the `**VLOOKUP**` function.
  prefs: []
  type: TYPE_NORMAL
- en: Also, unlike the complicated `**VLOOKUP**` function syntax, where you will be
    required to count columns, the `**XLOOKUP**` function parameters are self-explanatory
    — easy to read and understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in *[Figure 6.1](#fig6_1)*, we are looking up the amount sold
    on 15th January:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-6.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 6.1:** XLOOKUP exact match default'
  prefs: []
  type: TYPE_NORMAL
- en: '`=XLOOKUP(H3,SalesTable[[ Date]],SalesTable[Amount])`'
  prefs: []
  type: TYPE_NORMAL
- en: 'With `**XLOOKUP**`, all we need is three arguments: Lookup Value (H3), Lookup
    Array (Dates), and Return Array (`**Amounts**`). Furthermore, unlike `**VLOOKUP**`,
    data does not need to be sorted.'
  prefs: []
  type: TYPE_NORMAL
- en: The result must be corrected with `**VLOOKUP**`, as shown in *[Figure 6.2](#fig6_2)*,
    since the lookup array is not sorted, and we have skipped the match mode.
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-6.2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 6.2:** VLOOKUP approximate match default'
  prefs: []
  type: TYPE_NORMAL
- en: '`=VLOOKUP(H3,SalesTable[[ Date]:[Amount]],2)`'
  prefs: []
  type: TYPE_NORMAL
- en: '[Easily returns multiple adjacent and non-adjacent columns](toc.xhtml#s87a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`**XLOOKUP**` belongs to the new Dynamic array formulas in Excel, allowing
    one to return multiple results to a range of cells. This range is known as Spill
    Range, which can be multiple rows/columns or a table.'
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic array functions are designed to accommodate their output by automatically
    populating adjacent cells with results. This spill behavior allows the functions
    to return multiple values or an array of values rather than a single result.
  prefs: []
  type: TYPE_NORMAL
- en: The size of the spill range depends on the number of values returned by the
    function.
  prefs: []
  type: TYPE_NORMAL
- en: If we use a legacy array function like `**VLOOKUP**`, we must manually select
    adjacent cells and use the `**Ctrl + Shift + Enter**` to commit it. This is the
    only way it can populate adjacent cells.
  prefs: []
  type: TYPE_NORMAL
- en: As shown in *[Figure 6.3](#fig6_3)*, we are looking up the sales date and amount
    for customer “Luke Daly.”
  prefs: []
  type: TYPE_NORMAL
- en: '`=XLOOKUP(H3, SalesTable[Customer], SalesTable[[ Date]:[Amount]] )`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The only trick with returning multiple columns is ensuring that you select
    them as a return array. In the preceding example, we have selected both the date
    and amount columns: `**SalesTable[[ Date]:[Amount]]**`'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-6.3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 6.3:** XLOOKUP returns multiple adjacent columns'
  prefs: []
  type: TYPE_NORMAL
- en: 'To return multiple non-adjacent columns, we need to use the CHOOSECOLS functions
    in the return array argument to return the selected columns (see *[Figure 6.4](#fig6_4)*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-6.4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 6.4:** XLOOKUP returns multiple non-adjacent columns'
  prefs: []
  type: TYPE_NORMAL
- en: '`=XLOOKUP(I3,SalesTable[Customer],CHOOSECOLS(SalesTable[[ Date]:[Amount]],1,3))`'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we select three columns: date, item, and amount. Using `**CHOOSECOLS(SalesTable[[
    Date]:[Amount]],1,3)**`, the choose column returns only the first and third columns.'
  prefs: []
  type: TYPE_NORMAL
- en: The only thing to remember is that we can use the `**CHOOSECOLS**` function
    to return selected non-adjacent columns in one array.
  prefs: []
  type: TYPE_NORMAL
- en: '[Easily lookup data to the left or right](toc.xhtml#s88a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike the VLOOKUP function, the XLOOKUP function easily looks up data from
    the left.
  prefs: []
  type: TYPE_NORMAL
- en: In *[Figure 6.5](#fig6_5)*, we are looking for the date of the sale for the
    customer `**Luke**`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-6.5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 6.5:** XLOOKUP lookup to the left'
  prefs: []
  type: TYPE_NORMAL
- en: '`=XLOOKUP(I3,SalesTable[Customer],SalesTable[Date])`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though the dates are stored on the left side of the customer data, `**XLOOKUP**`
    still uses its simple three arguments, unlike `**VLOOKUP**`, which requires nesting
    of the IF function (see *[Figure 6.6](#fig6_6)*):'
  prefs: []
  type: TYPE_NORMAL
- en: '`=VLOOKUP(I3, IF({1,0},SalesTable[Customer],SalesTable[Date]), 2, 0)`'
  prefs: []
  type: TYPE_NORMAL
- en: With `**VLOOKUP**`, you must create a custom table array using the IF function,
    as we saw in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-6.6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 6.6:** VLOOKUP lookup to the left'
  prefs: []
  type: TYPE_NORMAL
- en: '[Easily accommodates column insertion/deletion](toc.xhtml#s89a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike the VLOOKUP function, XLOOKUP can handle the insertion and deletion of
    columns in a table.
  prefs: []
  type: TYPE_NORMAL
- en: For example, *[Figure 6.7](#fig6_7)* shows the two functions’ results before
    inserting a new column.
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-6.7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 6.7:** VLOOKUP and XLOOKUP functions before column insertion'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you insert a column in the table, `**VLOOKUP**` returns the wrong values,
    but `**XLOOKUP**` can dynamically handle the insertion (see *[Figure 6.8](#fig6_8)*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-6.8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 6.8:** VLOOKUP and XLOOKUP functions after column insertion'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note:** The `**VLOOKUP**` cannot handle the insertion because we have a hard-coded
    lookup column, that is, column 4.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we learned in *[Chapter 2, VLOOKUP IS DEAD: Or is it?](c02.xhtml)* You can
    overcome this by nesting the `**MATCH**` function in `**VLOOKUP**` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`=VLOOKUP(J3, SalesTable,MATCH(K2,SalesTable[#Headers],0),0)`'
  prefs: []
  type: TYPE_NORMAL
- en: When you delete a column, the `**VLOOKUP**` function returns an error, but `**XLOOKUP**`
    can dynamically handle the deletion. Refer to *[Figure 6.9](#fig6_9)* after we
    have deleted the items column.
  prefs: []
  type: TYPE_NORMAL
- en: The `**VLOOKUP**` function returns an error because it cannot find the return
    column, that is, column 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-6.9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 6.9:** VLOOKUP and XLOOKUP functions after column deletion'
  prefs: []
  type: TYPE_NORMAL
- en: '[Easily looks up data vertically or horizontally](toc.xhtml#s90a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the `**XLOOKUP**` function, we no longer need the `**HLOOKUP**` or modified
    `**VLOOKUP**` function to lookup data horizontally.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *[Figure 6.10](#fig6_10)*, we look up the supplier with the lowest quoted
    price:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-6.10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 6.10:** VLOOKUP and XLOOKUP function after column deletion'
  prefs: []
  type: TYPE_NORMAL
- en: '`=VLOOKUP(MIN(E67:G67),TRANSPOSE(IF({1;0},E67:G67,Reps)), 2,0)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`=XLOOKUP(MIN(E67:G67),E67:G67,$E$66:$G$66)`'
  prefs: []
  type: TYPE_NORMAL
- en: As we can see from the preceding functions, `**XLOOKUP**` is easy to write and
    explain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how the `**XLOOKUP**` function works:'
  prefs: []
  type: TYPE_NORMAL
- en: '`**MIN(E67:G67):**` the MIN function returns the smallest quoted price per
    item. This becomes our lookup value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**E67:G67:**` This is our lookup array, that is, all the price ranges. This
    is where we will find the position of the lowest price.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**$E$66:$G$66:**` This is our return array, that is, all the suppliers. We
    will return the supplier whose position corresponds to the lowest price.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Easily lookup data from the bottom up](toc.xhtml#s91a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, the XLOOKUP and VLOOKUP functions lookup data from top to bottom
    and return the first TRUE value.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *[Figure 6.11](#fig6_11)*, we look up the last date customer “Clay Rozendal”
    bought from us:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-6.11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 6.11:** XLOOKUP function lookup from bottom to top'
  prefs: []
  type: TYPE_NORMAL
- en: '`=XLOOKUP(H3,SalesTable[Customer],SalesTable[Date],,,-1)`'
  prefs: []
  type: TYPE_NORMAL
- en: The only trick here is to specify the correct search mode in `**XLOOKUP**`,
    that is, -1.
  prefs: []
  type: TYPE_NORMAL
- en: This search mode parameter determines the search behavior of the function, that
    is, 1 (first to last), -1 (last to first), or 2 (binary search). If omitted, `**XLOOKUP**`
    will default to 1 (first to last).
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to use the following function to get the same results using `**VLOOKUP**`.
    As shown in *[Figure 6.12](#fig6_12)*, the `**VLOOKUP**` function is complicated
    and hard to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '`=VLOOKUP(`'
  prefs: []
  type: TYPE_NORMAL
- en: '`MAX((SalesTable[Customer]=H3)*ROW(SalesTable[Customer])),`'
  prefs: []
  type: TYPE_NORMAL
- en: '`IF({1,0},(SalesTable[Customer]=H3)*ROW(SalesTable[Customer]),SalesTable[Date]),`'
  prefs: []
  type: TYPE_NORMAL
- en: '`2,0)`'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-6.12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 6.12:** VLOOKUP function lookup from bottom to top'
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to *[Chapter 2, VLOOKUP Is Dead: Or is it?](c02.xhtml)* for an explanation
    of how the preceding `**VLOOKUP**` function works.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Easily integrates wildcards in the lookup](toc.xhtml#s92a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the asterisk (*) or the question mark (?) wildcard characters creates
    a versatile and simpler lookup value.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in *[Figure 6.13](#fig6_13)*, we look up the date for a cost code
    that contains the letter “P”.
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-6.13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 6.13:** XLOOKUP using the asterisk Wildcards'
  prefs: []
  type: TYPE_NORMAL
- en: '`=XLOOKUP(I3,SalesTable[Cost Code],SalesTable[Date],,2)`'
  prefs: []
  type: TYPE_NORMAL
- en: The only trick here is remembering to use 2 as the match mode.
  prefs: []
  type: TYPE_NORMAL
- en: The match mode parameter determines how the function matches the lookup_value
    with the values in the lookup_array. It can be specified as 0 (exact match), -1
    (exact or next smaller), 1 (exact or next larger), or 2 (wild character match).
    If omitted, XLOOKUP will default to an exact match.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note:** The Asterisk (*) wildcard represents one or more characters in a
    text string. For example, P* will find any word that starts with the letter P,
    *P will find any word that ends with the letter P, and *P* will find any word
    with the letter P.'
  prefs: []
  type: TYPE_NORMAL
- en: Also, remember `**XLOOKUP**` function returns the first `**TRUE**` value.
  prefs: []
  type: TYPE_NORMAL
- en: We are not limited to using only the asterisk wildcard, but we can combine both,
    as shown in *[Figure 6.14](#fig6_14)*. In this example, we look up the date for
    a cost code whose fifth character is a “P”.
  prefs: []
  type: TYPE_NORMAL
- en: As discussed, a question mark (?) wildcard represents a single character in
    a text string. Therefore, a lookup value “????P*” will find any text string whose
    fifth character is the letter “P” followed by indefinite characters.
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-6.14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 6.14:** XLOOKUP using the question mark and asterisk Wildcards'
  prefs: []
  type: TYPE_NORMAL
- en: '[Returns a cell reference](toc.xhtml#s93a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the least known features of the `**XLOOKUP**` function is that it returns
    a cell reference, not just values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Though the cell reference is unseen, unlike the returned value, it can still
    be used, as shown in *[Figure 6.15](#fig6_15)*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-6.15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 6.15:** XLOOKUP returning cell reference'
  prefs: []
  type: TYPE_NORMAL
- en: '`=SUM(XLOOKUP(I95,Customers,XLOOKUP(J95,Regions,Data)):`'
  prefs: []
  type: TYPE_NORMAL
- en: '`XLOOKUP(I95,Customers,XLOOKUP(K95,Regions,Data)))`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how the formula works:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 1**: Create named ranges for the sections to use in the formulas. Select
    every region, as shown in *[Figure 6.16](#fig6_16)*, go to the Name box, and give
    it a name.![](images/Figure-6.16.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Figure 6.16:** Creating Named Ranges'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Step 2**: Write the nested `**XLOOKUP**` functions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The nested `**XLOOKUP**` function, XLOOKUP(J95,Regions,Data), returns the region
    data. This forms the return array of the main `**XLOOKUP**` function.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using the nested `**XLOOKUP**` function results as the return array, lookup
    the position of the customer:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**XLOOKUP(I95,Customers,XLOOKUP(J95,Regions,Data))**`'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To force the `**XLOOKUP**` functions to return the cell references, use the
    range operator (:) between the `**XLOOKUP**` returning the Eastern Region and
    the one returning the Western region (see *[Figure 6.17](#fig6_17)*):'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**XLOOKUP(I95,Customers,XLOOKUP(J95,Regions,Data)):**`'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`**XLOOKUP(I95,Customers,XLOOKUP(K95,Regions,Data))**`'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](images/Figure-6.17.jpg)'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: '**Figure 6.17:** XLOOKUP returns cell Ranges'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Step 3: Finally, sum up the above-returned range:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**=SUM(**`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`**XLOOKUP(I95,Customers,XLOOKUP(J95,Regions,Data)):**`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`**XLOOKUP(I95,Customers,XLOOKUP(K95,Regions,Data))**`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`**)**`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Note:** The `**XLOOKUP**` cannot return multiple rows/column references;
    it is limited to a single-cell reference. For multiple rows/columns references,
    use multiple `**XLOOKUP**` separated by a range operator (:)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Returns values in case of No Match](toc.xhtml#s94a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike other lookup functions, which return an error if a match is not found,
    XLOOKUP has an inbuilt “if no match” found argument.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in *[Figure 6.19](#fig6_19)*, we are only supposed to get a discount
    for discounted items while returning zero for the rest.
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-6.18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 6.18:** XLOOKUP if_not_ found argument'
  prefs: []
  type: TYPE_NORMAL
- en: 'We must use the `**if_not_found**` argument to capture the zero for non-discounted
    items, as shown in *[Figure 6.18](#fig6_18)*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-6.19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 6.19:** XLOOKUP Return a value if Match is not found'
  prefs: []
  type: TYPE_NORMAL
- en: '[Easily do a three-way lookup](toc.xhtml#s95a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unlike the VLOOKUP function, a nested XLOOKUP function easily does a three-way
    lookup, as shown in *[Figure 6.20](#fig6_20)*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-6.20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 6.20:** XLOOKUP three-way lookup'
  prefs: []
  type: TYPE_NORMAL
- en: '`=XLOOKUP(J126&K126,SaleReps&Products,`'
  prefs: []
  type: TYPE_NORMAL
- en: '`XLOOKUP(L126, Months, Amount))`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how the function works:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 1**: Create named ranges for the sections to use in the formulas. Select
    every region as highlighted in *[Figure 6.20](#fig6_20)*. To create a named range,
    Highlight the data, go to the Name box, and give it a Name. Finally, press Enter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Step 2**: Write the nested `**XLOOKUP**` functions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The nested `**XLOOKUP**` function, `**XLOOKUP(L126, Months, Amount)**`, returns
    the criterion Month data. This forms the return array of the main XLOOKUP function.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: As for the main `**XLOOKUP**` function, first, create a concatenated criterion
    — `**J126&K126**`. This returns a combination of the sales rep and product criteria.
    Then create combined Sales reps and Product columns, as shown in *[Figure 6.21](#fig6_21)*:![](images/Figure-6.21.jpg)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Figure 6.21:** XLOOKUP concatenated columns as lookup array'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Step 3**: Finally, get the position of the combined criteria in the combined
    columns. Then return the amount in the same position.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Note:** The order in which you concatenate the criteria should be the same
    order for the columns.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, if, in the preceding scenario, we created a `**SalesRep&Product**`
    combo criterion, then we must create a `**SalesRep&Product**` combo Lookup array.
    Any other order will not work.
  prefs: []
  type: TYPE_NORMAL
- en: '[Easily returns non-adjacent columns](toc.xhtml#s96a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using the preceding example, let us now use the XLOOKUP function to return
    the January and March Amounts, as shown in *[Figure 6.22](#fig6_22)*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-6.22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 6.22:** XLOOKUP return non-adjacent column values'
  prefs: []
  type: TYPE_NORMAL
- en: '`=XLOOKUP(J126&K126, SaleReps&Products, IF({1,0},Jan,Mar))`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how the function works:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 1**: Create named ranges for the sections to use in the formulas. Select
    every region as highlighted in *[Figure 6.22](#fig6_22)*. To create a named range,
    Highlight the data, go to the Name box, and give it a Name. Finally, press Enter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Step 2**: Use the IF function to return non-adjacent columns, as shown in
    *[Figure 6.23](#fig6_23)*. This is the only trick you need to remember.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Step 3**: Create a concatenated criterion — J126&K126\. This returns a combination
    of the sales rep and product criteria. Then create a combined lookup array of
    Sales reps and Product columns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Step 4**: Finally, get the position of the combined criteria in the combined
    lookup array columns. Then return the amounts, from the non-adjacent columns,
    in the same position.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Note**: The alternative to the IF function is the `**CHOOSE**` function as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`**=XLOOKUP(J126&K126, SaleReps&Products, CHOOSE({1,2},Jan,Mar))**`'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-6.23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 6.23:** IF return non-adjacent columns'
  prefs: []
  type: TYPE_NORMAL
- en: 'The alternative way is to use the Filter function to return non-adjacent columns
    as shown in *[Figure 6.24](#fig6_24)*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-6.24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 6.24:** FILTER function returns non-adjacent columns'
  prefs: []
  type: TYPE_NORMAL
- en: '`=XLOOKUP(J126&K126, SaleReps&Products,FILTER(Amounts,{1,0,1}))`'
  prefs: []
  type: TYPE_NORMAL
- en: The only trick to learn here is to learn how to use the include parameter to
    get non-adjacent rows (for more information, please refer to the FILTER function
    in the next chapter).
  prefs: []
  type: TYPE_NORMAL
- en: The “include” part of a filter function typically refers to the condition that
    specifies which elements from a given list or array should be included in the
    filtered result. If a condition is TRUE (1), then it is included; otherwise, it
    is not included.
  prefs: []
  type: TYPE_NORMAL
- en: '[Returns the last/first non-empty cell](toc.xhtml#s97a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Other than the `**LOOKUP**` function, a better alternative to getting the last/first
    non-empty cell is the `**XLOOKUP**` function, as shown in *[Figure 6.25](#fig6_25)*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-6.25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 6.25:** XLOOKUP last/first non-empty cells'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the First payment:'
  prefs: []
  type: TYPE_NORMAL
- en: '`=XLOOKUP(FALSE,ISBLANK(E158:I158),$E$157:$I$157)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the Last payment:'
  prefs: []
  type: TYPE_NORMAL
- en: '`=XLOOKUP(FALSE,ISBLANK(E158:I158),$E$157:$I$157,,-1)`'
  prefs: []
  type: TYPE_NORMAL
- en: Here is how the function works.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 1**: Check if the cells are blank using the ISBLANK function. This returns
    an array of TRUE/FALSE values, as shown in *[Figure 6.26](#fig6_26)*:![](images/Figure-6.26.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Figure 6.26:** ISBLANK array of TRUE/FALSE'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Step 2**: To get the first Payment, search for the first FALSE value in the
    array: `**=XLOOKUP(FALSE,ISBLANK(E158:I158),$E$157:$I$157)**`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Step 3**: To get the last Payment, we specify -1 as the search_mode. The
    XLOOKUP function will match the last FALSE value to the first FALSE value in the
    range: `**=XLOOKUP(FALSE,ISBLANK(E158:I158),$E$157:$I$157,,-1)**`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Easily lookup non-contiguous array](toc.xhtml#s98a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A nested XLOOKUP function also easily gets values from the non-contiguous array,
    as shown in *[Figure 6.27](#fig6_27)*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-6.27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 6.27:** XLOOKUP non-contiguous array'
  prefs: []
  type: TYPE_NORMAL
- en: '`=XLOOKUP(TRUE,[@Product]=”Chairs”,`'
  prefs: []
  type: TYPE_NORMAL
- en: '`XLOOKUP([@Amount], DiscountChairs[Amt], DiscountChairs[Disc],,-1),`'
  prefs: []
  type: TYPE_NORMAL
- en: '`XLOOKUP([@Amount], DiscountLaptops[Amt], DiscountLaptops[Disc],,-1))`'
  prefs: []
  type: TYPE_NORMAL
- en: Here is how the function works.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 1**: Check if the product is “Chairs”. This returns a TRUE/FALSE value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Step 2**: Since we use “TRUE” as the lookup value, the first nested XLOOKUP
    is executed if the preceding comparison is TRUE. It gets the discount percentage
    from the chairs’ discount table using an approximate match (we specify -1 as the
    match_mode for an approximate match lookup).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**XLOOKUP([@Amount], DiscountChairs[Amt], DiscountChairs[Disc],,-1),**`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Step 3**: If the value is `**FALSE**`, we execute the `**XLOOKUP**` that
    is in the **“if_not_found”** argument of the `**XLOOKUP**`. This `**XLOOKUP**`
    gets a discount percentage from the laptops’ discount table. Note: this is also
    an approximate match lookup.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**XLOOKUP([@Amount], DiscountLaptops[Amt], DiscountLaptops[Disc],,-1)**`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Easily returns duplicate lookup values](toc.xhtml#s99a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While, by default, the `**XLOOKUP**` function does not return multiple match
    values if the lookup_array contains duplicate values, it returns the first `**TRUE**`
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, you can achieve this if you nest the `**LARGE**` function, as shown
    in *[Figure 6.28](#fig6_28)*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-6.28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 6.28:** XLOOKUP returns duplicate lookup values.'
  prefs: []
  type: TYPE_NORMAL
- en: '`=XLOOKUP(`'
  prefs: []
  type: TYPE_NORMAL
- en: '`LARGE((Vendors=$J$183)*ROW(Vendors),ROW(A1)),`'
  prefs: []
  type: TYPE_NORMAL
- en: '`ROW(Vendors),January,””)`'
  prefs: []
  type: TYPE_NORMAL
- en: Here is how the function works.
  prefs: []
  type: TYPE_NORMAL
- en: '`**(Vendors=$J$183)**` checks which Vendor is equal to “Emily” and returns
    an array of TRUE/FALSE.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**(Vendors=$J$183)*ROW(Vendors)**` multiply the above array of TRUE/FALSE
    with the row numbers. This returns an array of row numbers for vendor Emily; otherwise,
    it returns zero (see *[Figure 6.29](#fig6_29)*):![](images/Figure-6.29.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Figure 6.29:** Row numbers for criterion vendor'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We need to iterate over these row numbers lists and return one at a time as
    the lookup value for `**XLOOKUP**`. We use the LARGE function for this task, which
    returns the row numbers from the Largest to the Smallest. Note ROW(A1) evaluates
    to 1, and as you drag the function down, it increases until the complete list
    is iterated. `**LARGE((Vendors=$J$183)*ROW(Vendors),ROW(A1)),**`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**XLOOKUP**` returns the January Amount for every row number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Conclusion](toc.xhtml#s100a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the power of the new XLOOKUP dynamic function and
    observed how easily it makes looking up values.
  prefs: []
  type: TYPE_NORMAL
- en: One of the unique features that sets `**XLOOKUP**` apart from other functions
    is its search mode from last to first, unlike functions that search from top to
    bottom.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike other functions that return errors if the lookup value is not found and
    we need to nest them in the IFERROR function, this is not the case with XLOOKUP,
    since it has an `**If_not_found**` argument where we can return a value or a function.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn of a better lookup function that can return
    multiple values if the `**lookup_array**` contains duplicate values — FILTER Function.
  prefs: []
  type: TYPE_NORMAL
- en: '[Points to remember](toc.xhtml#s101a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`**XLOOKUP**` function returns both value and cell reference.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**XLOOKUP**` is generally faster than traditional lookup functions like `**VLOOKUP**`
    or `**HLOOKUP**`, especially when dealing with large data sets. For values sorted
    in ascending order, specify 2 to enable binary search_mode and -2 for values sorted
    in descending order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Multiple choice questions](toc.xhtml#s102a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In an `**XLOOKUP**` function, what is the `**lookup_value**`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The value to be searched for in the lookup range
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The range of values to search within
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The range of values to return
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The criteria used to filter the results
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What happens if the default `**XLOOKUP**` function does not find a match for
    the `**lookup_value**` in the lookup range?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It returns an error
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It returns the closest matching value
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It returns a specified default value
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It returns the average of the lookup range
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following is NOT a valid argument in the XLOOKUP function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: “`**lookup_value**`”
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: “`**return_array**`”
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: “`**criteria_range**`”
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: “`**not_found**`”
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of the “`**if_not_found**`” argument in the `**XLOOKUP**`
    function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To specify the value to return if a match is found
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To specify the value to return if no match is found
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To specify the range to search for a match
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To specify the data type of the result
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which Excel version introduced the `**XLOOKUP**` function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Excel 2007
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Excel 2010
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Excel 2016
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Office 365 Excel
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the formula structure of the `**XLOOKUP**` function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`**=XLOOKUP(lookup_value, lookup_array, return_array)**`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`**=XLOOKUP(lookup_array, lookup_value, return_array)**`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`**=XLOOKUP(return_array, lookup_value, lookup_array)**`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`**=XLOOKUP(return_array, lookup_array, lookup_value)**`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Answers](toc.xhtml#s103a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: a
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: c
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: b
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: d
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
