- en: '[CHAPTER 7](toc.xhtml#c07)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[FILTER: The Ultimate Lookup Function](toc.xhtml#c07)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Introduction](toc.xhtml#s104a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will discuss one of the ultimate lookup functions—the Filter function.
    Unlike the `**XLOOKUP**` function, the `**FILTER**` function easily returns an
    array of all matches, not just the first match. This flexibility to return a subset
    of data, and not just a single entry, makes the FILTER one of the best functions
    in creating dynamic reports. Let us now explore the different scenarios where
    we can use the `**FILTER**` function to **analyze** data in more **customized**
    ways without the need for complex formulas.
  prefs: []
  type: TYPE_NORMAL
- en: '[Structure](toc.xhtml#s105a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will discuss the following 15 scenarios where the `**FILTER**`
    function is best suited:'
  prefs: []
  type: TYPE_NORMAL
- en: Return multiple columns and rows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return non-adjacent columns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easily use multiple criteria lookup using `AND`/`OR`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easily lookup all X and not Y items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easily lookup top or bottom n items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easily lookup X or Y and not both
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking up data using wildcards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking up weekday vs. weekend data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking up data that excludes holidays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking up ODD/EVEN numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking up items repeated N times
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking up items based on time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking up data based on week number, month, year
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking up common/uncommon values in two lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return end-of-month date items only
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Return multiple columns and rows](toc.xhtml#s106a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The FILTER function has one of the simplest and easiest-to-understand syntaxes—only
    three parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '`=FILTER(array, include, [if_empty])`'
  prefs: []
  type: TYPE_NORMAL
- en: array is the range/array of data you want to look up. This can be a table or
    single columns/rows.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: include is an array of `**TRUE/FALSE**`, where `**TRUE**` represents the values
    to return else `**FALSE**`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'NB: If the filtered array is in columns, the include MUST be the same length
    as this array. And if the array is in rows, the include MUST be the same width
    as this array.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`**[if_empty]- [optional]**` Value to return when no results are returned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, in *[Figure 7.1](#fig7_1)*, we want to look up all the contributions
    and corresponding dates for staff “Carl Jackson”.
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-7.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 7.1:** Returning Multiple Rows and Columns'
  prefs: []
  type: TYPE_NORMAL
- en: '`=FILTER(tblContribution[[Date]:[Amount]],tblContribution[Staff]=F3)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how the preceding function works:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the Columns to filter as our array. Here we are selecting adjacent columns;
    in the next example, we shall learn how to select non-adjacent columns→ `**tblContribution[[Date]:[Amount]]**`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check all instances where our criterion (Carl Jackson) appears in the staff
    list→ `**tblContribution[Staff]=F3.**` This returns a Boolean array (refer to
    *[Figure 7.2](#fig7_2)*), determining what values to include in the filter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](images/Figure-7.2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 7.2:** Creating the include parameter'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**: Since the FILTER function spills the results vertically/horizontally
    or both depending on your filtered array, ensure you have enough empty cells otherwise,
    you will get a `**#SPILL!**` Error (refer to *[Figure 7.3](#fig7_3)*).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-7.3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 7.3:** Obstructing text creating a spill error'
  prefs: []
  type: TYPE_NORMAL
- en: '[Return multiple non-adjacent columns and rows](toc.xhtml#s107a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As shown in *[Figure 7.4](#fig7_4)*, we have adjusted the data in the previous
    example to include items donated.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we want to return all donated items and amounts.
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-7.4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 7.4:** Returning non-adjacent Columns'
  prefs: []
  type: TYPE_NORMAL
- en: '`=FILTER(CHOOSECOLS(tblContribution,2,4),tblContribution[Staff]=G3)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how the preceding function works:'
  prefs: []
  type: TYPE_NORMAL
- en: To select the non-adjacent columns to filter, we shall use the `CHOOSECOLS`
    function. This function requires a table name and required column numbers → `**CHOOSECOLS(tblContribution,2,4)**`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: If you do not want to hardcode the columns in the `**CHOOSECOLS**` function,
    you can use the `**XMATCH**` function (refer to *[Figure 7.5](#fig7_5)*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check all instances where our criterion (Carl Jackson) appears in the staff
    list→ `**tblContribution[Staff]=F3**`. This returns a Boolean array, determining
    what values to include in the filter**.**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](images/Figure-7.5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 7.5:** CHOOSECOLS function dynamically returns non-adjacent columns'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another alternative to return non-adjacent columns is the use of nested `**FILTER**`
    functions as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`=FILTER(`'
  prefs: []
  type: TYPE_NORMAL
- en: '`FILTER(tblContribution,tblContribution[Staff]=G3),`'
  prefs: []
  type: TYPE_NORMAL
- en: '`{0,1,0,1})`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how the preceding function works:'
  prefs: []
  type: TYPE_NORMAL
- en: '`**FILTER(tblContribution,tblContribution[Staff]=G3)**` This nested FILTER
    function returns all the columns where the staff is equal to Carl Jackson who
    is stored in cell G3.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To get only the 2nd and 4th columns we use another `**FILTER**` function and
    specify these columns in the include parameter. As we have learned in the introduction
    section, the included parameter is an array of `**TRUE (1)**` /`**FALSE (0)**`,
    where TRUE represents the values to return else FALSE. Therefore, {0,1,0,1} will
    only return the second and fourth columns.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third alternative to returning non-adjacent columns is nesting the `**CHOOSE**`
    function. Just like the `**CHOOSECOL**` function, you can not only return non-adjacent
    columns but also rearrange them. Using the below formula, we can return the amount
    column first and then the date column.
  prefs: []
  type: TYPE_NORMAL
- en: '`=FILTER(`'
  prefs: []
  type: TYPE_NORMAL
- en: '`CHOOSE({1,2},tblContribution[Amount],tblContribution[Date]),tblContribution[Staff]=G51)`'
  prefs: []
  type: TYPE_NORMAL
- en: '[Easily use multiple criteria lookups using AND/OR](toc.xhtml#s108a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are not limited to a single criterion, as shown in the preceding examples.
    We can use the FILTER function with multiple criteria and different logics (`**AND**`/`**OR**`).
  prefs: []
  type: TYPE_NORMAL
- en: For example, in *[Figure 7.6](#fig7_6)*, we want to look up all donors whose
    donations were in `**ZAR**`, `**USD**`, or `**CHF**`.
  prefs: []
  type: TYPE_NORMAL
- en: '`=FILTER(Donors, COUNTIF(List, Currency))`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how the preceding function works:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the donor’s named range (Donors) as our filter array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `**COUNTIF**` function to count the number of times our list of currency
    criteria occurs in our database list of currencies. This returns an array of 1/0,
    as follows, where 1=TRUE, 0= FALSE.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**{0 0 0 0 0 1 0 1 0 0 0 1}**`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `**Filter**` function returns all the donors corresponding to the 1 values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](images/Figure-7.6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 7.6:** FILTER function Multiple Criteria OR logic using COUNTIF function'
  prefs: []
  type: TYPE_NORMAL
- en: The alternative to using the `**COUNTIF**` function is using the plus sign (+)
    to represent the OR logic, as shown in *[Figure 7.7](#fig7_7)*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-7.7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 7.7:** FILTER function Multiple Criteria OR logic using Plus sign
    (+)'
  prefs: []
  type: TYPE_NORMAL
- en: In *[Figure 7.8](#fig7_8)*, we want to know when and what amount staff `**Carl
    Jackson**` contributed to books.
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-7.8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 7.8:** FILTER function Multiple Criteria AND logic'
  prefs: []
  type: TYPE_NORMAL
- en: '`=FILTER($D$3:$E$14,($B$3:$B$14=G3)*($C$3:$C$14=H3))`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how the preceding function works:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the filter array `**($D$3:$E$14)**`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check if the staff equals Carl Jackson `**($B$3:$B$14=G3)**` and the items equals
    Books `**($C$3:$C$14=H3)**`**.** These return a Boolean array (`**TRUE/FALSE**`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since the FILTER function does not accept the nesting of the `**AND**` function,
    we use the asterisk (*) to represent the AND logic. When you multiply the preceding
    two Boolean arrays, we only get a value of 1 where all criteria are met. See *[Figure
    7.9](#fig7_9)*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](images/Figure-7.9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 7.9:** Using the asterisk (*) to represent the AND logic'
  prefs: []
  type: TYPE_NORMAL
- en: '[Easily lookup all X and not Y items](toc.xhtml#s109a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn how to use the NOT comparative operator (<>)
    in the FILTER function.
  prefs: []
  type: TYPE_NORMAL
- en: As shown in *[Figure 7.10](#fig7_10)*, we want to look up all students who scored
    a grade of A but not in the English subject.
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-7.10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 7.10:** Filtering data using the NOT comparative operator (<>)'
  prefs: []
  type: TYPE_NORMAL
- en: '`=FILTER(C49:C61,(F49:F61=”A”)=(D49:D61<>”English”))`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how the preceding function works:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the Students filter array **(C49:C61**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check if the grade is equal to `**A**` **(F49:F61=”A”)** and if the subject
    is NOT equal to `**English**` (`**D49:D61<>English**`). These return a Boolean
    array—`**TRUE**` (where both checks are true) and `**FALSE**` (where one/both
    tests are false)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The alternative uses the greater-than-comparative operator, as shown in *[Figure
    7.11](#fig7_11)*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-7.11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 7.11:** Filtering data using the Greater than (>) comparative operator'
  prefs: []
  type: TYPE_NORMAL
- en: '`=FILTER(C49:C61,(F49:F61=”A”)>(D49:D61=”English”))`'
  prefs: []
  type: TYPE_NORMAL
- en: The only trick to learn here is that Excel treats the FALSE value as zero (0)
    and one (1) as TRUE; then, only in the instances where 1>0 will the result be
    TRUE. See *[Figure 7.12](#fig7_12)*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-7.12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 7.12:** Comparing Boolean values'
  prefs: []
  type: TYPE_NORMAL
- en: '[Easily lookup top or bottom n items](toc.xhtml#s110a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike the previously learned Lookup functions, the FILTER function easily returns
    the top or bottom items, as shown in *[Figure 7.13](#fig7_13)*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-7.13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 7.13:** Filtering the Top or Bottom items'
  prefs: []
  type: TYPE_NORMAL
- en: To Filter the top 3
  prefs: []
  type: TYPE_NORMAL
- en: '`=FILTER(Donors, Donations>=LARGE(Donations,3))`'
  prefs: []
  type: TYPE_NORMAL
- en: To Filter the bottom 3
  prefs: []
  type: TYPE_NORMAL
- en: '`=FILTER(Donors, Donations<=SMALL(Donations,3))`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how the preceding function works:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the donors’ named range filter array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the LARGE function to return the third largest value `**( LARGE(Donations,3)
    )**` Or the SMALL function to return the third smallest value `**( SMALL(Donations,3)
    ).**`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To filter the top items, check the donation amounts that are greater or equal
    to the third largest `**(Donations>=LARGE(Donations,3)).**` To filter the bottom
    items, check the donation amounts that are lesser or equal to the 3rd smallest
    `**(Donations<=SMALL(Donations,3)).**` These return a Boolean array—TRUE (where
    both checks are true) and FALSE (where one/both tests are false).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Filter Function returns all the donors corresponding to the TRUE values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Easily lookup X or Y and not both](toc.xhtml#s111a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is not a frequent lookup problem, but it is worth knowing how to solve
    it.
  prefs: []
  type: TYPE_NORMAL
- en: We need to look up all students who scored Grade A or took English, but not
    both. See *[Figure 7.14](#fig7_14)*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-7.14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 7.14:** Filtering all X or Y but not Both'
  prefs: []
  type: TYPE_NORMAL
- en: '`=FILTER(C82:C94,(F82:F94=”A”)-(D82:D94=”English”))`'
  prefs: []
  type: TYPE_NORMAL
- en: The only trick to learn is using the minus sign (-) as a comparison operator.
  prefs: []
  type: TYPE_NORMAL
- en: Here is how the comparison works.
  prefs: []
  type: TYPE_NORMAL
- en: If one comparison is `TRUE` (1) and the other is `FALSE` (0), then the comparison
    would be 1-0=1\. Thus, Overall will be TRUE. When comparing two `FALSE` conditions
    0-0=0, thus overall `FALSE`. When comparing two `TRUE` conditions, 1-1=0, this
    also would be an overall `FALSE`. See *[Figure 7.15](#fig7_15)*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-7.15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 7.15:** Minus Sign (-) comparison operator'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: In Excel, FALSE equals 0 value, and any other value equals `TRUE`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is why in *[Figure 7.15](#fig7_15)*, the value of −1 is equal to `TRUE`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Looking up data using wildcards](toc.xhtml#s112a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unfortunately, the two wildcard characters (***?**) do not work with the FILTER
    function.
  prefs: []
  type: TYPE_NORMAL
- en: However, there is a walkaround using a combination of SEARCH and ISNUMBER functions,
    as shown in *[Figure 7.16](#fig7_16)*.
  prefs: []
  type: TYPE_NORMAL
- en: The task is to filter all producers whose product contains the word “Milk”.
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-7.16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 7.16:** Filtering data using wildcards'
  prefs: []
  type: TYPE_NORMAL
- en: '`=FILTER(Producers, ISNUMBER(SEARCH(“Milk”, Product)))`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how the preceding function works:'
  prefs: []
  type: TYPE_NORMAL
- en: The search function returns a number if the product name contains the word “milk”,
    else it returns an error `**(SEARCH(“Milk”, Product)).**`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ISNUMBER` function returns an array of `TRUE/FALSE` which will be used as
    the include criteria in the `FILTER` function. `ISNUMBER` returns `TRUE` if the
    returned value by the `SEARCH` function is a number; else, it returns `FALSE`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Looking up weekday or weekend data](toc.xhtml#s113a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Analyzing transactions based on the weekday or weekend is required, especially
    for sales analysts.
  prefs: []
  type: TYPE_NORMAL
- en: This can be easily done using a combination of the `FILTER` function and the
    `WEEKDAY` function, as shown in *[Figure 7.17](#fig7_17)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To Filter Weekday sold items:'
  prefs: []
  type: TYPE_NORMAL
- en: '`=FILTER(tblSportSale[Item],WEEKDAY(tblSportSale[Date],2)<6)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'To Filter Weekend sold items:'
  prefs: []
  type: TYPE_NORMAL
- en: '`=FILTER(tblSportSale[Item],WEEKDAY(tblSportSale[Date],2)>=6)`'
  prefs: []
  type: TYPE_NORMAL
- en: Here is how the preceding formula works.
  prefs: []
  type: TYPE_NORMAL
- en: Given the date of the sale, the `WEEKDAY` function `**( WEEKDAY(tblSportSale[Date],2))**`
    returns a number between 1 and 7 representing the day of the week. Monday(1) to
    Sunday(7)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the Weekdays dates, these are dates with a day number less than 6, while
    Weekend dates have a day number greater or equal to 6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](images/Figure-7.17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 7.17:** Filtering Weekday or Weekend data'
  prefs: []
  type: TYPE_NORMAL
- en: '[Looking up data that excludes holidays and weekends](toc.xhtml#s114a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous example, we saw how to look up either weekday or weekend-sold
    items.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming we have holidays, how do we look up items sold on workdays only? As
    shown in *[Figure 7.18](#fig7_18)*, you can exclude Holidays and Weekends by using
    the `po` function.
  prefs: []
  type: TYPE_NORMAL
- en: '`=FILTER(SportSales[Item],WORKDAY(SportSales[Date]-1,1,Holidays)=SportSales[Date])`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how the preceding function works:'
  prefs: []
  type: TYPE_NORMAL
- en: '`**WORKDAY(SportSales[Date]-1, 1, Holidays)**` will subtract one day from the
    Sales date to get the initial date, then add one working day to find the next
    working day after that initial date, while excluding any dates specified in the
    “Holidays” list. If the Sales date is not a holiday or a weekend, the WORKDAY
    function will return the same date; otherwise, it will return the next working
    day.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compare the returned working days with the Sales dates, `**WORKDAY(SportSales[Date]-1,1,Holidays)=SportSales[Date].**`
    This comparison returns `**TRUE**` if the dates are the same otherwise, `**FALSE**`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `FILTER` function returns only items corresponding to the `TRUE` values
    from the preceding array.
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-7.18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 7.18:** Filtering working days data only'
  prefs: []
  type: TYPE_NORMAL
- en: '[Looking up ODD/EVEN numbers](toc.xhtml#s115a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let us assume that you are an auditor and want to extract only Even numbered
    invoices, as shown in *[Figure 7.19](#fig7_19)*.
  prefs: []
  type: TYPE_NORMAL
- en: Here is the formula you can use for this task.
  prefs: []
  type: TYPE_NORMAL
- en: '`=FILTER(B147:B158,ISEVEN(0+B147:B158))`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how the preceding function works:'
  prefs: []
  type: TYPE_NORMAL
- en: '`**ISEVEN(0+B147:B158)**` `ISEVEN` function returns an array of `TRUE/FALSE.`
    TRUE for all even numbered invoices else, `FALSE`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: To force the `ISEVEN` function to evaluate the entire range as an array, you
    must add a zero in your referenced range else the function will return a `#VALUE`
    error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The FILTER function returns only Invoices that correspond to the TRUE values
    of the array returned earlier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To filter the ODD numbered invoices, change the formula as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`=FILTER(B147:B158,ISODD(0+B147:B158))`'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-7.19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 7.19:** Filtering Even values only'
  prefs: []
  type: TYPE_NORMAL
- en: '[Looking up items repeated N times](toc.xhtml#s116a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using the previous data on contributions, let us see how to filter all staff
    who have donated more than two times, as shown in *[Figure 7.20](#fig7_20)*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-7.20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 7.20:** Filtering Items Repeated n times'
  prefs: []
  type: TYPE_NORMAL
- en: '`=UNIQUE(FILTER(Staff, COUNTIF(Staff, Staff)>2))`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how the preceding function works:'
  prefs: []
  type: TYPE_NORMAL
- en: '`**COUNTIF(Staff, Staff)**` COUNTIF function returns an array of the number
    of times a staff is repeated in the list. Refer to *[Figure 7.21](#fig7_21)*.![](images/Figure-7.21.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Figure 7.21:** COUNTIF function showing repeats per item'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, we check which items have been repeated more than two times `**COUNTIF(Staff,
    Staff)>2.**` This returns an array of `TRUE/FALSE`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `FILTER` function only includes staff corresponding to the TRUE value, as
    shown in *[Figure 7.22](#fig7_22)*.![](images/Figure-7.22.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Figure 7.22:** Filtered duplicate values'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To eliminate duplicate values, we use the `**UNIQUE function UNIQUE(FILTER(Staff,
    COUNTIF(Staff, Staff)>2))**`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Looking up items based on time](toc.xhtml#s117a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the attendance data is collected in DateTime format, as shown in *[Figure
    7.23](#fig7_23)*. Yet we are required to look up that data using the time portion
    of the DateTime only.
  prefs: []
  type: TYPE_NORMAL
- en: When faced with such a problem, the only thing to remember is that the time
    value is always stored as a fraction of 24 hours while the Date is stored as a
    serial number.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, time will be the value after the decimal in a DateTime serial number.
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-7.23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 7.23:** Filtered based on time'
  prefs: []
  type: TYPE_NORMAL
- en: '`=FILTER(tblStudents,MOD(tblStudents[[Arrival ]],1)>G164)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how the preceding function works:'
  prefs: []
  type: TYPE_NORMAL
- en: '`**MOD(tblStudents[[Arrival ]],1)**` When used with a divisor of 1, the MOD
    function always returns the fractional part of a number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**MOD(tblStudents[[Arrival ]],1)>G164**` This condition checks whether the
    calculated fractional part of the `**Arrival**` time (`**MOD**` result) is greater
    than the value in cell G164\. This is essentially checking if the minutes’ portion
    of the arrival time is greater than the value in G164.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The FILTER function is used to retrieve rows from the `**tblStudents**` table
    based on a certain condition. In this case, it filters the rows where the calculated
    fractional part of the `**Arrival**` time is greater than the value in cell G164.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Looking up data based on week number, month, and year](toc.xhtml#s118a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we learned how to filter data based on a weekday or
    weekend. In this section, we shall learn how to look up data based on Week number,
    Month, and Year.
  prefs: []
  type: TYPE_NORMAL
- en: In *[Figure 7.24](#fig7_24)*, we are looking up all items sold in Week 3.
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-7.24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 7.24:** Filtered based on a Week number'
  prefs: []
  type: TYPE_NORMAL
- en: '`=FILTER(SportSales[Item],WEEKNUM(SportSales[Date]+0)=3)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note:**'
  prefs: []
  type: TYPE_NORMAL
- en: The WEEKNUM function does not accept a range of data. It returns the `**#VALUE**`
    error. We, however, can force it by adding a zero `**(SportSales[Date]+0)**` to
    the range.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The WEEKNUM function returns an array of week numbers (Refer to *[Figure 7.25](#fig7_25)*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we compare the calculated week numbers (from the preceding step) to the
    value, we return an array of `TRUE` and `FALSE`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `FILTER` function is used to filter the rows where the values from the preceding
    step are `TRUE`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](images/Figure-7.25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 7.25:** WEEKNUM returning an array of Week numbers'
  prefs: []
  type: TYPE_NORMAL
- en: To filter specific months’ data, use the month function as shown in *[Figure
    7.26](#fig7_26)*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-7.26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 7.26:** Filtered based on a Month'
  prefs: []
  type: TYPE_NORMAL
- en: '`=FILTER(SportSales[Item],MONTH(SportSales[Date])=6)`'
  prefs: []
  type: TYPE_NORMAL
- en: The only thing to note here is that the `MONTH` function returns an array of
    month numbers. Everything else is as explained in the `WEEKNUM` function.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, *[Figure 7.27](#fig7_27)* shows how to filter data using years values.
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-7.27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 7.27:** Filtered based on a Year'
  prefs: []
  type: TYPE_NORMAL
- en: '`=FILTER(SportSales[Item],YEAR(SportSales[Date])=2022)`'
  prefs: []
  type: TYPE_NORMAL
- en: The only thing to note here is that the `YEAR` function returns an array of
    year numbers. Everything else is as explained in the preceding functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[Lookup common/uncommon items in two lists](toc.xhtml#s119a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Comparing values in a list is a common activity in Excel. For example, in *[Figure
    7.28](#fig7_28)*, we look up common and new customers between two lists.
  prefs: []
  type: TYPE_NORMAL
- en: To get new (uncommon) customers
  prefs: []
  type: TYPE_NORMAL
- en: '`=FILTER(Current_Customers, COUNTIF(LastYear_Customers,Current_Customers)=0)`'
  prefs: []
  type: TYPE_NORMAL
- en: To get old(common) customers
  prefs: []
  type: TYPE_NORMAL
- en: '`=FILTER(Current_Customers, COUNTIF(LastYear_Customers,Current_Customers)=0)`'
  prefs: []
  type: TYPE_NORMAL
- en: The only trick with the function is the use of the `**COUNTIF**` function to
    count how many times items in the new list are repeated on the old list.
  prefs: []
  type: TYPE_NORMAL
- en: '`**►COUNTIF(LastYear_Customers, Current_Customers)**` count the number of customers
    who appeared both in the LastYear_Customers range and the Current_Customers range.
    It returns an array of 1 and 0\. Where 1= common in both and 0=uncommon.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-7.28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 7.28:** Filtered common/uncommon items between lists'
  prefs: []
  type: TYPE_NORMAL
- en: '[Return end-of-the-month date items only](toc.xhtml#s120a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you want to return what was sold on the last date of any month, as shown
    in *[Figure 7.29](#fig7_29)*, you must use the `**EOMONTH**` function.
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-7.29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 7.29:** Filtered items sold on the last day of the month'
  prefs: []
  type: TYPE_NORMAL
- en: '`=FILTER(Sport_Sales[Item], EOMONTH(Sport_Sales[Date]+0,0)=Sport_Sales[Date])`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**:'
  prefs: []
  type: TYPE_NORMAL
- en: '`**EOMONTH**` function does not accept a range of data. It returns the `**#VALUE**`
    error. We, however, can force it by adding a zero (SportSales[Date]+0) to the
    range.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `**EOMONTH**` function returns an array of the last day of a month given
    a date (refer to *[Figure 7.30](#fig7_30)*).![](images/Figure-7.30.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Figure 7.30:** EOMONTH return an array of the last date in months'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When we compare the calculated end-of-month dates (from the preceding step)
    to the sales dates, we return an array of `**TRUE**` and `**FALSE**`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `**FILTER**` function is used to filter the rows where the values from the
    preceding step are `**TRUE**`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Conclusion](toc.xhtml#s121a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned one of the easiest-to-understand and use lookup
    functions in Excel—the `**FILTER**` function. It is mostly recommended when you
    want to return multiple values.
  prefs: []
  type: TYPE_NORMAL
- en: The `**FILTER**` function stands as a powerful tool within the Excel arsenal,
    providing users with a dynamic and efficient means of extracting specific data
    subsets from extensive datasets. Through this chapter, we have explored the intricacies
    of the `**FILTER**` function, delving into its syntax, parameters, and real-world
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: By harnessing the capabilities of the `**FILTER**` function, Excel users can
    streamline their data analysis processes, enhancing both accuracy and efficiency.
    This function empowers users to effortlessly retrieve relevant information based
    on complex criteria, enabling informed decision-making, and facilitating comprehensive
    insights into their data.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we shall learn about Power Query.
  prefs: []
  type: TYPE_NORMAL
- en: '[Points to remember](toc.xhtml#s122a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `**FILTER**` function works seamlessly with other Excel dynamic arrays functions
    like `**SORT**`, `**UNIQUE**`, and `**TRANSPOSE**`, allowing you to create complex
    data manipulation workflows.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The FILTER function is non-volatile. Unlike some other functions that recalculate
    every time you make a change, the `**FILTER**` function recalculates only when
    the underlying data or criteria change, improving overall worksheet performance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The FILTER function does not accommodate the AND/OR functions. So, in case of
    multiple criteria use an asterisk (*) to invoke the AND operation and a Plus sign
    (+) to invoke an OR operation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The FILTER function can handle various data types, including numbers, text,
    dates, and more, making it suitable for a wide range of data analysis tasks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Quiz](toc.xhtml#s123a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which parameter of the `**FILTER**` function is used to display a custom message
    or value when no matching results are found?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: array
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: criteria
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`**[if_empty]**`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`**[include]**`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following is NOT a benefit of using the `**FILTER**` function over
    traditional filtering techniques?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Dynamic array spill
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Compatibility with other dynamic array functions
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Volatile recalculations
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Simplified multiple criteria handling
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What Excel error is returned by the FILTER function if no matching results are
    found based on the criteria?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`**#REF!**`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`**#VALUE!**`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`**#CALC!**`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`**#NUM!**`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What Excel function can be used to re-order the results Column of the `**FILTER**`
    function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`**SORT**`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`**SUM**`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`**VLOOKUP**`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`**CHOOSE**`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following formulas uses the FILTER function to extract rows from
    a table where the “`**Region**`” column is equal to “`**East**`”?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: =`**FILTER(Table1, “Region”, “East”)**`
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: =`**FILTER(Table1, “Region”=”East”)**`
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: =`**FILTER(Table1, Table1[Region]=”East”)**`
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: =`**FILTER(Table1, “East”, “Region”)**`
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Answers](toc.xhtml#s124a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`**[if_empty]**`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Volatile recalculations
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`**#CALC!**`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`**CHOOSE**`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`**=FILTER(Table1, Table1[Region]=”East”)**`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
