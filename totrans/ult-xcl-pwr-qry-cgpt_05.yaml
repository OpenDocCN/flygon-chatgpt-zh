- en: '[CHAPTER 3](toc.xhtml#c03)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[INDEX and MATCH](toc.xhtml#c03)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Introduction](toc.xhtml#s45a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will introduce what is regarded as the `**VLOOKUP**` function replacement
    — `**INDEX**` and `**MATCH**`. These nested functions are so popular in such a
    way that some users think of them as individual functions. We shall first analyze
    these two functions individually and later see why they are such a powerful combination.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, since the book is about Mastering Excel, we will learn how to combine
    them with other functions to solve complex lookup issues.
  prefs: []
  type: TYPE_NORMAL
- en: '[Structure](toc.xhtml#s46a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: INDEX, MATCH, and the two-way lookup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Three-way lookup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reverse-lookup single result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reverse-lookup multiple results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple criteria lookup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returning multiple columns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Horizontal lookup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lookup non-contiguous array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lookup using wildcards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lookup based on text length
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lookup items in a list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lookup unique values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[INDEX, MATCH, and the two-way lookup](toc.xhtml#s47a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A two-way lookup is used to find a specific value by matching two criteria.
    It’s commonly used when you have a data table and need to retrieve a value at
    the intersection of a row and column.
  prefs: []
  type: TYPE_NORMAL
- en: The INDEX function returns the data at the intersection of a given row and column.
    Therefore, the function requires an array of data, an optional row number (if
    it is a ***single-row array), and an optional column number (if it is a single-column
    array)***.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by looking up a multiple-row and multiple-column array, as shown
    in *[Figure 3.1](#fig3_1)*. We are trying to answer the question, “*What amount
    did customer Gupta buy from the Western region?*”:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-3.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 3.1:** INDEX multiple rows and columns lookup'
  prefs: []
  type: TYPE_NORMAL
- en: '`=INDEX(RegionSales,10,3)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note:** If your data is in a table (this is the date in range A2:D13), the
    row count starts after the header.'
  prefs: []
  type: TYPE_NORMAL
- en: This is why in *[Figure 3.1](#fig3_1)*, Gupta is in row 10, not 11.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of selecting the whole table, we can select the column or row you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in *[Figure 3.2](#fig3_2)*, since we know we want Western region
    sales, we can select the entire column and provide only the row number containing
    our customer:'
  prefs: []
  type: TYPE_NORMAL
- en: '`=INDEX(RegionSales[Western],10)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: If your data is in a single column, you only need to provide the row
    number.'
  prefs: []
  type: TYPE_NORMAL
- en: You can input 1 as the column number, but it is unnecessary since you have selected
    only one column — Western Region data.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you can re-write the preceding function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`=INDEX(RegionSales[Western],10,1)`'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-3.2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 3.2:** INDEX single-column lookup'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you can select the entire row that contains customer **“**`**Gupta**`**”**
    and only provide the column number, as shown in *[Figure 3.3](#fig3_3)*:'
  prefs: []
  type: TYPE_NORMAL
- en: '`=INDEX( A11:D11, 3 )`'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-3.3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 3.3:** INDEX single-row lookup'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note:** If your data is in a single row, you need only provide the column
    number.'
  prefs: []
  type: TYPE_NORMAL
- en: You can input 1 as the row number, but it is unnecessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you can re-write the preceding function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`=INDEX(A11:D11,1,3)`'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned how the INDEX function works, let us revise the `MATCH`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we learned in *[Chapter 2, “VLOOKUP IS DEAD: Or is it”](c02.xhtml)*, the
    MATCH function returns the relative position of an item in an array. For example,
    in *[Figure 3.2](#fig3_2)*, we can dynamically get the row number instead of hardcoding
    it. We achieve this using the `**MATCH**` function, as shown in *[Figure 3.4](#fig3_4)*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-3.4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 3.4:** MATCH function gets the row number'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note:** The `**MATCH**` function returns row 10, yet from the figure, we
    can see that the customer is in row 11.'
  prefs: []
  type: TYPE_NORMAL
- en: As we noted earlier, this is because the MATCH function returns the relative
    position of the value within the lookup array. Since the header data is not within
    the lookup array, the `**MATCH**` function has ignored it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Knowing the `**MATCH**` function can automate the hardcoding of the row number
    in the `**INDEX**` function, let us substitute the row number with it (see *[Figure
    3.5](#fig3_5)*):'
  prefs: []
  type: TYPE_NORMAL
- en: '`=INDEX(RegionSales[Western],`'
  prefs: []
  type: TYPE_NORMAL
- en: '`MATCH(F3,RegionSales[Customer],0))`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the optimal way of writing a simple INDEX and MATCH combo:'
  prefs: []
  type: TYPE_NORMAL
- en: Select only the column/row you require.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `**MATCH**` function to get the criterion row/column instead of hardcoding
    it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](images/Figure-3.5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 3.5:** INDEX and MATCH function'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are not limited to selecting single-column or single-row arrays. We can
    select a complete table and nest two MATCH functions to make our solution dynamic
    (see *[Figure 3.6](#fig3_6)*):'
  prefs: []
  type: TYPE_NORMAL
- en: '`=INDEX(RegionSales,`'
  prefs: []
  type: TYPE_NORMAL
- en: '`MATCH(F3,RegionSales[Customer],0),`'
  prefs: []
  type: TYPE_NORMAL
- en: '`MATCH(G3,RegionSales[#Headers],0))`'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-3.6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 3.6:** Dynamic two-way lookup'
  prefs: []
  type: TYPE_NORMAL
- en: '[Three-way lookup](toc.xhtml#s48a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A three-way lookup formula allows you to get data from a table using three
    criteria (see *[Figure 3.7](#fig3_7)*):'
  prefs: []
  type: TYPE_NORMAL
- en: '`=INDEX(RegionSales,`'
  prefs: []
  type: TYPE_NORMAL
- en: '`MATCH(G18&H18,RegionSales[Product]&RegionSales[Customer],0),`'
  prefs: []
  type: TYPE_NORMAL
- en: '`MATCH(G20,RegionSales[#Headers],0))`'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-3.7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 3.7:** Dynamic three-way lookup'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding function performs as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`**G18&H18**` returns a single combined criterion, that is, “ChairsRuby.”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**RegionSales[Product]&RegionSales[Customer]**` joins the two columns and
    return a one-way array of products and customers that we can use to look up the
    combo criterion (see ***[Figure 3.8](#fig3_8)***):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tip**: When creating a one-way array, follow the **same order** as when creating
    the combo criteria.'
  prefs: []
  type: TYPE_NORMAL
- en: In our example, the combo criterion is a join between `**Product and Customer**`
    (`**ChairsRuby**`); this is the reason we have followed the same order when creating
    the single array.
  prefs: []
  type: TYPE_NORMAL
- en: '`**MATCH(G18&H18, RegionSales[Product]&RegionSales[Customer],0)**` returns
    the row number in the custom one-way array that contains the combo criterion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**MATCH(G20, RegionSales[#Headers],0))**` returns the column number in the
    table headers that contain the month criterion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember that this is an array function since we are doing the criteria and
    columns joining. Therefore, if you do not have an Office 365 subscription, remember
    to click **Ctrl + Shift + Enter** when you complete writing it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](images/Figure-3.8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 3.8:** One-way array'
  prefs: []
  type: TYPE_NORMAL
- en: '[Reverse-lookup single result](toc.xhtml#s49a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A reverse lookup is the opposite of the two-way lookup function discussed earlier.
    You start with data in an intersection and return the row and column headers.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in *[Figure 3.10](#fig3_10)*, we know the exam, but we must look
    up the tutor and the hall:'
  prefs: []
  type: TYPE_NORMAL
- en: '`=INDEX(Tutors&”-”&Halls,`'
  prefs: []
  type: TYPE_NORMAL
- en: '`SUM((Exams=E33)*ROW(Exams))-ROW(Halls),`'
  prefs: []
  type: TYPE_NORMAL
- en: '`SUM((Exams=E33)*COLUMN(Exams))-COLUMN(Tutors))`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how the preceding function works:'
  prefs: []
  type: TYPE_NORMAL
- en: '`**Tutors&”-”&Halls**` returns a custom table containing the combination of
    every tutor and the hall.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**(Exams=E33)*ROW(Exams)**` checks if our criteria exam is in the list of
    exams and returns an array of `**TRUE / FALSE**`, which, when multiplied by the
    exam rows, returns 0 where FALSE and the row number where TRUE (see ***[Figure
    3.9](#fig3_9)***).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We `**SUM**` the array to get a single row number from the preceding step.
    Since `**INDEX**` starts counting row numbers from the header, we then deduct
    the row of the header: `SUM((Exams=E33) * ROW(Exams)) - ROW(Halls)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Similar steps to the ones mentioned earlier are repeated to get the column
    number: `SUM((Exams=E33) * COLUMN(Exams))- COLUMN(Tutors))`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember that this is an array function since we create the custom tutors and
    sessions table. Therefore, if you do not have an Office 365 subscription, remember
    to click **Ctrl + Shift + Enter** when you complete writing it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](images/Figure-3.9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 3.9:** Exam row number'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip:** Always deduct Row or Column headers in your count if you have yet
    to include them in the table array.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-3.10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 3.10:** Reverse lookup'
  prefs: []
  type: TYPE_NORMAL
- en: '[Reverse-lookup multiple results](toc.xhtml#s50a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let us learn how to return multiple items if you have duplicates in your
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the example in the previous section, assume patient `**Jack Dan**` had
    two appointments. *[Figure 3.12](#fig3_12)* shows how to return the two appointments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`=INDEX(Doctor&” “&session,`'
  prefs: []
  type: TYPE_NORMAL
- en: '`MATCH(TRUE,`'
  prefs: []
  type: TYPE_NORMAL
- en: '`INDEX(Patients,, LARGE(IF(Patients=$G$47,COLUMN(Patients)-COLUMN(Doctor)),ROW(A1)))=$G$47,0),`'
  prefs: []
  type: TYPE_NORMAL
- en: '`LARGE((Patients=$G$47)*COLUMN(Patients)-COLUMN(Doctor),ROW(A1)))`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This function works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`**Doctor&” “&session**` returns a custom table containing the combination
    of every doctor and the session.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**IF(Patients=$G$47, COLUMN(Patients)-COLUMN(Doctor))**` checks if our criteria
    patient is in the list of patients and returns the column numbers where this is
    `**TRUE**`, else `**FALSE**` (see ***[Figure 3.11](#fig3_11)***):![](images/Figure-3.11.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Figure 3.11:** Check columns'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`**LARGE(IF(Patients=$G$47,COLUMN(Patients)-COLUMN(Doctor)),ROW(A1))**` returns
    the largest column number, that is, 2\. We use `ROW(A1)`, which returns 1, and
    the number increments as we scroll our formula down.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**INDEX(Patients,,LARGE(IF(Patients=$G$47,COLUMN(Patients)-COLUMN(Doctor)),ROW(A1)))**`
    use the `**INDEX**` function to filter the data per column (see ***[Figure 3.12](#fig3_12)***):![](images/Figure-3.12.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Figure 3.12:** Filter one column at a time'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`**MATCH(TRUE, INDEX(Patients,, LARGE(IF(Patients=$G$47, COLUMN(Patients)-COLUMN(Doctor)),
    ROW(A1)))=$G$47,0),**` checks if the patient is in the filtered column and returns
    an array of `**TRUE/FALSE**`. The `**MATCH**` function returns the relative position
    of the only `**TRUE**` value, which forms our row number for the `**INDEX**` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we have the row number, the last part is to get the column number
    using the `**LARGE: LARGE(IF(Patients=$G$47,COLUMN(Patients)-COLUMN(Doctor)),
    ROW(A1))**`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fill the formula downward to return all the appointments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember that this is an array function since we create the custom doctors and
    sessions table. Therefore, if you do not have an Office 365 subscription, remember
    to click **Ctrl + Shift + Enter** when you complete writing it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](images/Figure-3.13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 3.13:** Reverse-lookup multiple items'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note:** When all appointments have been returned, the INDEX function starts
    to return the `**#NUM**` error.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Multiple criteria lookup](toc.xhtml#s51a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we learned in the previous section on three-way lookup, the trick to doing
    a multiple criteria lookup is joining the criteria into one using the ampersand
    (&) (see *[Figure 3.14](#fig3_14)*):'
  prefs: []
  type: TYPE_NORMAL
- en: '`=INDEX(tblSalesT20[Amount],`'
  prefs: []
  type: TYPE_NORMAL
- en: '`MATCH(E60&F60,tblSalesT20[Customer]&tblSalesT20[Sales Date],0))`'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-3.14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 3.14:** Multiple criteria lookup'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding function performs as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`**E60&F60**` returns a single combo criterion for the customer and dates **“Carl
    Jackson40192.”**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**tblSalesT20[Customer]&tblSalesT20[Sales Date]**` returns a single combo
    array for the customer and dates (see *[Figure 3.15](#fig3_15)*):![](images/Figure-3.15.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Figure 3.15:** Combo array'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`**MATCH(E60&F60,tblSalesT20[Customer]&tblSalesT20[Sales Date],0))**` The `**MATCH**`
    function returns the row number of the combo criterion in the combo array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember that this is an array function since we create the custom combo array.
    Therefore, if you do not have an Office 365 subscription, remember to click **Ctrl
    + Shift + Enter** when you complete writing it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Returning multiple columns](toc.xhtml#s52a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, the `**INDEX**` and `**MATCH**` combo returns a single column.
    If we want multiple columns, we must modify the `**MATCH**` function, as shown
    in *[Figure 3.16](#fig3_16)*:'
  prefs: []
  type: TYPE_NORMAL
- en: '`=INDEX(RegionSale21,`'
  prefs: []
  type: TYPE_NORMAL
- en: '`MATCH(F75,RegionSale21[Customer],0),`'
  prefs: []
  type: TYPE_NORMAL
- en: '`MATCH(G74:H74,RegionSale21[#Headers],0))`'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-3.16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 3.16:** Multiple columns'
  prefs: []
  type: TYPE_NORMAL
- en: The only trick is finding the relative positions of the multiple columns using
    the MATCH function, `**MATCH(G74:H74,RegionSale21[#Headers],0))**`, by highlighting
    the two criteria (G74:H74), the `**MATCH**` function returns an array of columns
    ({2,3}), which forces the `**INDEX**` function to return both columns.
  prefs: []
  type: TYPE_NORMAL
- en: This is also an array function; therefore, if you do not have an Office 365
    subscription, remember to click **Ctrl + Shift + Enter** when you complete writing
    it.
  prefs: []
  type: TYPE_NORMAL
- en: '[Horizontal lookup](toc.xhtml#s53a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unlike the VLOOKUP function, the `**INDEX**` function is not limited to a vertical
    lookup. The return array can be stored in any direction if you provide the correct
    column or row number (see *[Figure 3.17](#fig3_17)*):'
  prefs: []
  type: TYPE_NORMAL
- en: '`=INDEX(Suppliers,,`'
  prefs: []
  type: TYPE_NORMAL
- en: '`MATCH( MIN(B91:D91),B91:D91,0))`'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-3.17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 3.17:** Horizontal lookup'
  prefs: []
  type: TYPE_NORMAL
- en: The only trick here is using the MIN function to return the lowest quoted price
    per item. This price becomes our lookup value for the `**MATCH**` function. The
    `**MATCH**` function then returns the relative position of this minimum price.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note:** Since the suppliers are in a single-row array, we can skip the row
    number, as shown in the preceding formula.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Lookup non-contiguous array](toc.xhtml#s54a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As shown in *[Figure 3.18](#fig3_18)*, the INDEX function has two syntax options:'
  prefs: []
  type: TYPE_NORMAL
- en: Array Option, which expects single or multiple contiguous arrays of data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Reference Option, which expects references to cells or a range of non-contiguous
    cells. Here are some important points to note on non-contiguous ranges:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ranges must be enclosed in parentheses and separated by commas.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Ranges must be on the same worksheet; otherwise, the function will result in
    a `**#VALUE**` error.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Ranges can be of different lengths but must contain the referenced row or column
    number. An out-of-range reference will result in a `**#REF**` error.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Ranges are selected in the `**[area_num]**` argument of the `**INDEX**` function.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](images/Figure-3.18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 3.18:** INDEX reference option'
  prefs: []
  type: TYPE_NORMAL
- en: 'The example given in *[Figure 3.19](#fig3_19)* shows different discounts for
    chairs and laptops. We can use the following function to look up the different
    tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`=INDEX((Chairs_Disc[Disc],Laptops_Disc[Disc]),`'
  prefs: []
  type: TYPE_NORMAL
- en: '`MATCH([@Amount],`'
  prefs: []
  type: TYPE_NORMAL
- en: '`CHOOSE(IF([@Product]=”Chairs”,1,2),Chairs_Disc[Amt],Laptops_Disc[Amt]),1),,`'
  prefs: []
  type: TYPE_NORMAL
- en: '`IF([@Product]=”Chairs”,1,2))`'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-3.19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 3.19:** INDEX non-contiguous array'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding function works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`**( Chairs_Disc[Disc], Laptops_Disc[Disc] )**` returns the two non-contiguous
    discount columns for Chairs and Laptops.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IF([@Product]=”Chairs”,1,2),** returns a 1 if the product on the table is
    chairs; otherwise, it returns 2\. This is the index that the `**CHOOSE**` function
    will determine to select the amount column in either the Chairs or Laptops table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**MATCH([@Amount],CHOOSE(IF([@Product]=”Chairs”,1,2),Chairs_Disc[Amt],Laptops_Disc[Amt]),1)**`
    MATCH function returns the approximate relative position of the amount in the
    discount table amount column.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since we are selecting single-column arrays, we can ignore the column index
    argument and jump to the area number argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IF([@Product]=”Chairs”,1,2),** return a 1 if the product on the table is
    chairs; otherwise, it returns 2\. This determines which of the two non-contiguous
    discount columns for Chairs and Laptops will be selected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Lookup using wildcards](toc.xhtml#s55a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As learned in the last chapter, specifically in the `**VLOOKUP**` partial lookup
    section, the `**INDEX-MATCH**` combo can also use the two popular wildcard characters
    (? *).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in *[Figure 3.20](#fig3_20)*, we want to look up the amount for
    an invoice containing the letter “P”:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-3.20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 3.20:** INDEX using an asterisk wildcard character'
  prefs: []
  type: TYPE_NORMAL
- en: '`=INDEX(tblinvoicez[Amount],`'
  prefs: []
  type: TYPE_NORMAL
- en: '`MATCH(“*”&G117&”*”,tblinvoicez[Invoice ‘#],0))`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some points to remember while using Wildcard characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Asterisk (*)**: The asterisk wildcard represents zero or more characters
    in a text string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Question mark (?)**: The question mark wildcard represents a single character
    in a text string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can combine the asterisk and the question marks to define your search further.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is how the preceding function works:'
  prefs: []
  type: TYPE_NORMAL
- en: '`**“*”&G117&”*”**` returns *P*, which means there could be many characters
    before and after the letter `**P**`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**MATCH**` function returns the first invoice’s relative row position whose
    invoice number contains the letter `**P**`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**INDEX**` function returns the invoice amount in the same row number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Suppose you want to look up values for an invoice number whose fifth character
    is the letter “P”?
  prefs: []
  type: TYPE_NORMAL
- en: 'In such a scenario, we shall use the question mark (?) as the wildcard character
    to represent any single character (see ***[Figure 3.21](#fig3_21)***):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-3.21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 3.21:** INDEX using mixed wildcard characters'
  prefs: []
  type: TYPE_NORMAL
- en: '`=INDEX(tblinvoicez[Amount],`'
  prefs: []
  type: TYPE_NORMAL
- en: '`MATCH(“????”&J117&”*”,tblinvoicez[Invoice ‘#],0))`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how the preceding function works:'
  prefs: []
  type: TYPE_NORMAL
- en: '`**“????”&J117&”*”**` returns `????P*`, which means any four characters could
    be before the letter “P”. Therefore, “P” is the fifth character, but there are
    multiple characters after it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MATCH function returns the first invoice’s relative row position where an invoice
    number’s fifth character is the letter “P”.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: INDEX function returns the invoice amount in the same row number.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Lookup based on text length](toc.xhtml#s56a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In *[Figure 3.22](#fig3_22)*, we assume all invoice back-orders can be identified
    by the length of the invoice number (that is, 8 characters):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-3.22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 3.22:** Lookup text based on Length'
  prefs: []
  type: TYPE_NORMAL
- en: 'To look up these back-ordered invoices, we use the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '`=INDEX(Invoices[Amount],`'
  prefs: []
  type: TYPE_NORMAL
- en: '`MATCH( G132,LEN(Invoices[Invoice ‘#]),0))`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how the preceding function works:'
  prefs: []
  type: TYPE_NORMAL
- en: '`**LEN(Invoices[Invoice ‘#]), the**` `LEN` function returns an array of invoice
    number lengths. This becomes the lookup array argument for the MATCH function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**MATCH**` function returns the first invoice’s relative row position, whose
    length is 8 characters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**INDEX**` function returns the invoice amount in the same row number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Assuming you had multiple back-ordered invoices, as shown in *[Figure 3.23](#fig3_23)*.
    Let us learn how to return the last match with the help of the `**MAX**` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '`=INDEX(Invoices[Amount],`'
  prefs: []
  type: TYPE_NORMAL
- en: '`MAX(`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(LEN(Invoices[Invoice ‘#])=G132)*ROW(Invoices[Invoice ‘#])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`-ROW(Invoices[#Headers])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`))`'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-3.23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 3.23:** Lookup the last match'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how the preceding function works:'
  prefs: []
  type: TYPE_NORMAL
- en: '`**LEN(Invoices[Invoice ‘#])**` LEN function returns an array of invoice number
    lengths.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**LEN(Invoices[Invoice ‘#])=G132**` checks which invoice length is equal to
    8 and returns an array of `**TRUE/FALSE**`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Get the row numbers by multiplying the TRUE/FALSE array with row numbers: `**(LEN(Invoices[Invoice
    ‘#])=G132)*ROW(Invoices[Invoice ‘#])**`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjust the row numbers count by deducting the header row.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To get the last low, use the `**MAX**` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**INDEX**` function returns the invoice amount in the last matching row number
    returned by the `**MAX**` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Lookup items in a list](toc.xhtml#s57a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Looking up items in a list is relatively easy when you understand the `**COUNTIF**`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *[Figure 3.24](#fig3_24)*, we want to look up the first customer who bought
    from us using any of the currencies in the list in cell G:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-3.24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 3.24:** Lookup item in a list'
  prefs: []
  type: TYPE_NORMAL
- en: '`=INDEX(Sales_Currency[Customer],`'
  prefs: []
  type: TYPE_NORMAL
- en: '`MATCH(1,COUNTIF(List, Sales_Currency[Currency]),0))`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how the preceding function works:'
  prefs: []
  type: TYPE_NORMAL
- en: '`**COUNTIF(List, Sales_Currency[Currency])**` `**COUNTIF**` function returns
    an array of 1/0, where 1 is the count of the currency if it is found in the list,
    else 0\. This becomes the lookup array argument for the `**MATCH**` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**MATCH**` function returns the first invoice’s relative row position whose
    count is 1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**INDEX**` function returns the customer in the same row number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we want to return all the items and not just the first match, we must modify
    our formula, as shown in *[Figure 3.25](#fig3_25)*:'
  prefs: []
  type: TYPE_NORMAL
- en: '`=INDEX(`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Sales_Currency[Customer],`'
  prefs: []
  type: TYPE_NORMAL
- en: '`LARGE(`'
  prefs: []
  type: TYPE_NORMAL
- en: '`COUNTIF(List, Sales_Currency[Currency])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*ROW(Sales_Currency[Currency])-ROW(Sales_Currency[#Headers]), ROW(A1))`'
  prefs: []
  type: TYPE_NORMAL
- en: '`)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how the preceding function works:'
  prefs: []
  type: TYPE_NORMAL
- en: '`COUNTIF(List, Sales_Currency[Currency])`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*ROW(Sales_Currency[Currency])` `**COUNTIF**` function returns an array of
    1/0, where 1 is the count of the currency if it is found in the list, else 0\.
    Multiply this array with row numbers to return a list of row numbers that contain
    the items in the list. Remember to adjust the row numbers to start the count after
    the headers by deducting the header row number.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We need to iterate over this row numbers list and return one at a time as the
    row argument for the `**INDEX**` function. We use the LARGE function for this
    task, which returns the row numbers from the largest to the smallest. Note ROW(A1)
    evaluates to 1, and as you drag the function down, it increases until the full
    list is iterated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**INDEX**` function uses each row number returned by the LARGE function and
    returns the corresponding customer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please note that the `**INDEX**` function returns the `**#VALUE**` error after
    all customers have been returned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](images/Figure-3.25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 3.25:** Lookup multiple items in a list'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we do not want the formula to return the error, we could nest it in the
    `**IFERRROR**` function, as shown in the following syntax. The `**IFERROR**` function
    now returns blanks instead of errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '`=IFERROR(`'
  prefs: []
  type: TYPE_NORMAL
- en: '`INDEX(Sales_Currency[Customer],`'
  prefs: []
  type: TYPE_NORMAL
- en: '`LARGE(`'
  prefs: []
  type: TYPE_NORMAL
- en: '`COUNTIF(List,Sales_Currency[Currency])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*ROW(Sales_Currency[Currency])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`-ROW(Sales_Currency[#Headers]),ROW(A1))),`'
  prefs: []
  type: TYPE_NORMAL
- en: '`“”)`'
  prefs: []
  type: TYPE_NORMAL
- en: '[Lookup unique value](toc.xhtml#s58a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Mastering the `**COUNTIF**` function is a big step in enhancing our lookup
    skills. For example, if you want to look up a unique value in Excel, you must
    utilize the `**COUNTIF**` function, as shown in *[Figure 3.26](#fig3_26)*:'
  prefs: []
  type: TYPE_NORMAL
- en: '`=INDEX(Sales[Customer],`'
  prefs: []
  type: TYPE_NORMAL
- en: '`MATCH(TRUE, COUNTIF(Sales[Currency],Sales[Currency])=1,0))`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how this function works:'
  prefs: []
  type: TYPE_NORMAL
- en: '`**COUNTIF(Sales[Currency],Sales[Currency])**` `**COUNTIF**` function returns
    an array of counts for each currency in the column. Since we are looking for the
    unique values, we check which count is equal to 1 ► `**COUNTIF(Sales[Currency],Sales[Currency])=1**`.
    This comparison returns an array of `TRUE/FALSE`, where `TRUE=UNIQUE` and `FALSE=DUPLICATES`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**MATCH**` functions return the relative row position of the *first* `**TRUE**`
    value in the preceding array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**INDEX**` function returns the customer in the same row number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](images/Figure-3.26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 3.26:** Lookup unique items'
  prefs: []
  type: TYPE_NORMAL
- en: '[Lookup bottom *n* values](toc.xhtml#s59a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Looking up the bottom values is relatively easy if we first understand the
    `**IF**` and `**SMALL**` functions. For example, in *[Figure 3.27](#fig3_27)*,
    we look up the three customers with the least sales:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-3.27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 3.27:** Lookup bottom items'
  prefs: []
  type: TYPE_NORMAL
- en: '`=INDEX(BottomSale[Customer],`'
  prefs: []
  type: TYPE_NORMAL
- en: '`SMALL(`'
  prefs: []
  type: TYPE_NORMAL
- en: '`IF((BottomSale[Amt]<=SMALL(BottomSale[Amt],3)),`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(BottomSale[Amt]<=SMALL(BottomSale[Amt],3))*ROW(BottomSale[Amt])-ROW(BottomSale[#Headers]),`'
  prefs: []
  type: TYPE_NORMAL
- en: '`“”),ROW(A1)))`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how the preceding function works:'
  prefs: []
  type: TYPE_NORMAL
- en: '`**SMALL(BottomSale[Amt],3)**` the `SMALL` function returns the third smallest
    amount — 28,600\. The next step is to check which amount is less or equal to this
    third smallest amount ► `**(BottomSale[Amt]<=SMALL(BottomSale[Amt],3))**`.This
    comparison returns an array of `TRUE/FALSE`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**BottomSale[Amt]<=SMALL(BottomSale[Amt],3))*ROW(BottomSale[Amt])**` `**])-ROW(BottomSale[#Headers])**`
    To get an array of row numbers, we multiply the `TRUE/FALSE` array with the amounts’
    row numbers. Remember to adjust the row numbers to start the count after the headers
    by deducting the header row number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next step is to replace the negative values in the preceding array with
    blanks using the IF function: `**IF((BottomSale[Amt]<=SMALL(BottomSale[Amt],3)),
    (BottomSale[Amt]<=SMALL(BottomSale[Amt],3))*ROW(BottomSale[Amt])-ROW(BottomSale[#Headers]),
    “”)**`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to iterate over this row numbers list and return one at a time as the
    row argument for the INDEX function. For this task, we use the `SMALL` function,
    which returns the row numbers from the smallest to the largest. Note `ROW(A1)`
    evaluates to 1, and as you drag the function down, it increases until the full
    list is iterated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**INDEX**` function uses each row number returned by the `**SMALL**` function
    and returns the corresponding customer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please note that the `**INDEX**` function returns the “#NUM” error after all
    customers have been returned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we learned in the previous section, if you do not want the INDEX function
    to return an error, nest it in the `IFERROR` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`=IFERROR(`'
  prefs: []
  type: TYPE_NORMAL
- en: '`INDEX(BottomSale[Customer],`'
  prefs: []
  type: TYPE_NORMAL
- en: '`SMALL(`'
  prefs: []
  type: TYPE_NORMAL
- en: '`IF((BottomSale[Amt]<=SMALL(BottomSale[Amt],3)),`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(BottomSale[Amt]<=SMALL(BottomSale[Amt],3))`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*ROW(BottomSale[Amt])-ROW(BottomSale[#Headers]),`'
  prefs: []
  type: TYPE_NORMAL
- en: '`“”),ROW(A1))),`'
  prefs: []
  type: TYPE_NORMAL
- en: '`“”)`'
  prefs: []
  type: TYPE_NORMAL
- en: '[Conclusion](toc.xhtml#s60a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter offers a better lookup method for `VLOOKUP — INDEX/MATCH` combination.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three primary reasons why this combination is the better option:
    (i) It allows us to select not only a two-column table but also a single column/row
    array; (ii) The ability to select a single column/row array makes it flexible
    to look up not only to the left or right but also vertically or horizontally;
    (iii) Since it does not default to an approximate match, this combination is less
    prone to errors.'
  prefs: []
  type: TYPE_NORMAL
- en: For those without an Office365 subscription, this combination of `INDEX/MATCH`
    is the most efficient lookup method.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will investigate why some Excel users still use one
    of the oldest legacy lookup functions — `LOOKUP` and `HLOOKUP`.
  prefs: []
  type: TYPE_NORMAL
- en: '[Points to remember](toc.xhtml#s61a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to the `VLOOKUP` function, the `INDEX/MATCH` combination returns the
    first match single value by default. If we want multiple values to nest, we can
    use the SMALL/LARGE functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unlike the `VLOOKUP` function, the `INDEX/MATCH` function row count is based
    on the array selected, not the default row number returned by the ROW function.
    Therefore, you must adjust the row count if your data does not start from the
    topmost row.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
