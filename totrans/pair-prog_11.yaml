- en: '| ![image](d2d_images/chapter_title_corner_decoration_left.png) |  | ![image](d2d_images/chapter_title_corner_decoration_right.png)
    |'
  prefs: []
  type: TYPE_TB
- en: '![image](d2d_images/chapter_title_above.png)'
  prefs: []
  type: TYPE_IMG
- en: Unit Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](d2d_images/chapter_title_below.png)'
  prefs: []
  type: TYPE_IMG
- en: '![A picture containing dark, night sky  Description automatically generated](d2d_images/image013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Image by [Gerd Altmann](https://pixabay.com/users/geralt-9301/?utm_source=link-attribution&utm_medium=referral&utm_campaign=image&utm_content=3625406) from [Pixabay](https://pixabay.com/?utm_source=link-attribution&utm_medium=referral&utm_campaign=image&utm_content=3625406)
  prefs: []
  type: TYPE_NORMAL
- en: As developers, we know the importance of unit testing in ensuring the quality
    and reliability of our software. Yet, we also know the struggles that come with
    creating effective unit tests - the time and effort required, the complexity of
    the testing process, and the challenge of ensuring comprehensive coverage. Personally,
    I have often found myself skipping unit tests in the interest of saving time,
    only to regret it later when bugs and errors inevitably arise.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore how Copilot and ChatGPT can help ease the pain
    of creating effective unit tests, by generating test cases for a simple Angular
    service. Through this process, we will see how these tools can help enhance the
    unit testing process.
  prefs: []
  type: TYPE_NORMAL
- en: The Service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The service itself is simple enough. I wanted to build a means of setting and
    retrieving two different unique IDs my app can use when making service calls.
    The first is a “conversation ID” that will be set as an HTTP header for all network
    calls for a specific user for a given session. It will not change until the application
    user manually refreshes the screen, closes the browser, or logs out and back in.
  prefs: []
  type: TYPE_NORMAL
- en: The second is a “correlation ID.” This will also get sent with each HTTP call,
    but it changes with every request. I won’t show the network calls, just the service
    to generate the IDs.
  prefs: []
  type: TYPE_NORMAL
- en: The Service API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are three primary requirements the service implements.
  prefs: []
  type: TYPE_NORMAL
- en: It will give me the same conversation ID whenever I ask, unless one does not
    exist. In that case, it needs to give me a new one and return it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It will give me a fresh correlation ID every time I request one. I should never
    get the same ID twice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It will provide a way for me to force a fresh conversation ID.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The implementation will use UUIDs for both the conversationId and the correlationId.
    In case you aren’t aware of the term UUID, I asked ChatGPT to define it:'
  prefs: []
  type: TYPE_NORMAL
- en: What is a UUID?
  prefs: []
  type: TYPE_NORMAL
- en: A UUID, or Universally Unique Identifier, is a type of identifier that is used
    to uniquely identify information in a distributed system. A UUID is a 128-bit
    number represented as a sequence of hexadecimal digits, typically displayed in
    groups separated by hyphens. UUIDs are designed to be unique across both space
    and time, meaning that they should never collide or be duplicated, even if generated
    by different systems at different times. UUIDs are commonly used in a variety
    of contexts, including as keys in databases, as identifiers for files or objects
    in storage systems, and as session IDs in web applications. The use of UUIDs helps
    to ensure that there is no ambiguity or conflict when multiple systems need to
    refer to the same entity, and also helps to provide an additional layer of security
    by making it more difficult to guess or manipulate identifiers.
  prefs: []
  type: TYPE_NORMAL
- en: In short, UUIDs are perfect identifiers to use for my purposes in identifying
    and correlating HTTP calls across various systems.
  prefs: []
  type: TYPE_NORMAL
- en: The code itself small and straightforward. I will reproduce the entirety of
    the service here for reference.
  prefs: []
  type: TYPE_NORMAL
- en: import { Injectable } from '@angular/core';
  prefs: []
  type: TYPE_NORMAL
- en: import { v4 as uuidv4 } from 'uuid';
  prefs: []
  type: TYPE_NORMAL
- en: '@Injectable({'
  prefs: []
  type: TYPE_NORMAL
- en: 'providedIn: ''root'''
  prefs: []
  type: TYPE_NORMAL
- en: '})'
  prefs: []
  type: TYPE_NORMAL
- en: export class CorrelationService {
  prefs: []
  type: TYPE_NORMAL
- en: 'conversationId: string = '''';'
  prefs: []
  type: TYPE_NORMAL
- en: resetConversationId() {
  prefs: []
  type: TYPE_NORMAL
- en: this.conversationId = uuidv4();
  prefs: []
  type: TYPE_NORMAL
- en: return this.conversationId;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: getConversationId() {
  prefs: []
  type: TYPE_NORMAL
- en: return this.conversationId || this.resetConversationId();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: getCorrelationId() {
  prefs: []
  type: TYPE_NORMAL
- en: return uuidv4();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three functions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'resetConversationId: creates a brand new UUID and assigns it to the internal
    coversationId variable and returns that new value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'getConversationId: returns the internal conversationId if it has a value, or
    calls resetConversationID and returns its result.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'getCorrelationId: simply returns a new UUID every time it’s called.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As I said, it is a very simple service.
  prefs: []
  type: TYPE_NORMAL
- en: The Testing Framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I want to start by reviewing the test code that is automatically generated by
    the Angular CLI. I do not mean for this to be a comprehensive introduction to
    testing, but I will explain the basics. It should be enough for you to follow
    along in your own tests.
  prefs: []
  type: TYPE_NORMAL
- en: By default, when you use the Angular CLI to create a service, it will also create
    a default test file. In my case, it created this for me.
  prefs: []
  type: TYPE_NORMAL
- en: import { TestBed } from '@angular/core/testing';
  prefs: []
  type: TYPE_NORMAL
- en: import { CorrelationService } from './correlation.service';
  prefs: []
  type: TYPE_NORMAL
- en: describe('CorrelationService', () => {
  prefs: []
  type: TYPE_NORMAL
- en: 'let service: CorrelationService;'
  prefs: []
  type: TYPE_NORMAL
- en: beforeEach(() => {
  prefs: []
  type: TYPE_NORMAL
- en: TestBed.configureTestingModule({});
  prefs: []
  type: TYPE_NORMAL
- en: service = TestBed.inject(CorrelationService);
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: it('should be created', () => {
  prefs: []
  type: TYPE_NORMAL
- en: expect(service).toBeTruthy();
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: The first import line brings in the Angular testing class called TestBed. This
    class contains most of the basic testing framework.
  prefs: []
  type: TYPE_NORMAL
- en: The second pulls in the service to be tested, also known as the “System Under
    Test,” or SUT. This is assigned to the variable service.
  prefs: []
  type: TYPE_NORMAL
- en: describe
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: describe('CorrelationService', () => {
  prefs: []
  type: TYPE_NORMAL
- en: With most JavaScript testing frameworks, tests are organized into one or more
    describe functions. These functions encapsulate related tests and isolate the
    inner tests from other, unrelated tests. They can be nested, as you will see shortly.
  prefs: []
  type: TYPE_NORMAL
- en: The describe function is called with two parameters.
  prefs: []
  type: TYPE_NORMAL
- en: The test label. In this case, the name of the service to be tested.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The function that contains the tests themselves. Here it is an arrow function.
    It contains a single variable representing the service, but nothing is assigned
    to it yet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: beforeEach
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: beforeEach(() => {
  prefs: []
  type: TYPE_NORMAL
- en: TestBed.configureTestingModule({});
  prefs: []
  type: TYPE_NORMAL
- en: service = TestBed.inject(CorrelationService);
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: Directly inside this function is another function call, beforeEach, which itself
    contains another arrow function. This function is called by the testing framework
    before every unit test is executed.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this function is a call to TestBed.configureTestingModule({}), and you
    can see that it is being passed an empty object as its only argument. This object
    contains the test module’s options. It can accept just about every option a normal
    Angular module can. Most tests use this to configure Angular’s dependency injection
    system to inject test doubles required by the SUT. My service has no dependencies,
    so there is nothing to configure.
  prefs: []
  type: TYPE_NORMAL
- en: Other Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Not shown are some other functions that can contain setup/tear-down instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'beforeAll: called once before any tests inside the describe are run. This is
    typically used to set up the state required by all tests, but which won’t change
    from test to test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'afterEach: called after each unit test function in the describe. This is used
    to tear down or reset the state to undo any side effects that a test might have
    created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'afterAll: called once after all tests in the describe have been run. Again,
    this is used to reset the global state so that effects from your describe function
    don’t bleed into others.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: it
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: it('should be created', () => {
  prefs: []
  type: TYPE_NORMAL
- en: expect(service).toBeTruthy();
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: This function defines a single unit test. You can create as many it functions
    as you want inside your describe. The generated test comes with a single it function.
    Its signature matches that of describe, in that it takes a label and a function
    defining the test.
  prefs: []
  type: TYPE_NORMAL
- en: 'When combined with its enclosing describe, the it functions should read like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[describe Label] [it Label]: Pass/Fail'
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, when you read the one pre-generated test, it should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'CorrelationService should be created: Pass'
  prefs: []
  type: TYPE_NORMAL
- en: Consider this phrasing when you create your own tests.
  prefs: []
  type: TYPE_NORMAL
- en: There is a lot more to Angular testing than this, but I wanted to make sure
    I explained what you would be seeing before I started.
  prefs: []
  type: TYPE_NORMAL
- en: The Tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With that explanation out of the way, let’s look at the tests GitHub Copilot
    generated. If you are following along, it should be a simple matter of creating
    a brand new describe for each function to be tested. This isn’t strictly necessary.
    It is perfectly legal to put all your tests inside a single describe, but I find
    that doing this way gives Copilot the context it needs to write the tests properly.
  prefs: []
  type: TYPE_NORMAL
- en: I entered the first line below as a hint, and Copilot generated the tests for
    me.
  prefs: []
  type: TYPE_NORMAL
- en: describe('resetConversationId', () => {
  prefs: []
  type: TYPE_NORMAL
- en: it('should return conversationId', () => {
  prefs: []
  type: TYPE_NORMAL
- en: service.resetConversationId();
  prefs: []
  type: TYPE_NORMAL
- en: expect(service.getConversationId()).toBeTruthy();
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: This test simply checks to see whether calling getConversationId() returns a
    truthy, or non-empty value.
  prefs: []
  type: TYPE_NORMAL
- en: it('should return conversationId if it exists', () => {
  prefs: []
  type: TYPE_NORMAL
- en: service.resetConversationId();
  prefs: []
  type: TYPE_NORMAL
- en: const conversationId = service.conversationId;
  prefs: []
  type: TYPE_NORMAL
- en: expect(service.getConversationId()).toEqual(conversationId);
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: This test calls getConversationId() twice, expecting the two values to be identical.
    If not, the test will fail.
  prefs: []
  type: TYPE_NORMAL
- en: it('should return conversationId if it exists', () => {
  prefs: []
  type: TYPE_NORMAL
- en: service.resetConversationId();
  prefs: []
  type: TYPE_NORMAL
- en: const conversationId = service.conversationId;
  prefs: []
  type: TYPE_NORMAL
- en: expect(service.getConversationId()).toEqual(conversationId);
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: No, that isn’t a typo. It generated two identical tests. I don’t know why. You’ll
    see that sometimes with Copilot. It can be mildly annoying, but the purpose is
    so that I can write fewer tests manually. In this case, I’m comfortable with the
    results.
  prefs: []
  type: TYPE_NORMAL
- en: It generated tests that exercise the function appropriately. One simple refactor
    I could make would be to move the call to service.resetConversationId() into the
    beforeEach function, guaranteeing it gets called before each test is executed.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the tests it gave me, I am not convinced I need separate tests for
    resetConversationId, but it would be easy enough to add them.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look now at the tests for getCorrelationId. According to the requirements,
    it should always return a new one every time it’s called. For this one, instead
    of asking Copilot to complete my describe, I used a comment and let it write everything.
  prefs: []
  type: TYPE_NORMAL
- en: // Test getCorrelationId
  prefs: []
  type: TYPE_NORMAL
- en: it('should return correlationId', () => {
  prefs: []
  type: TYPE_NORMAL
- en: expect(service.getCorrelationId()).toBeTruthy();
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: It built a single function for me but didn’t go any further. In fact, it isn’t
    a very helpful test, but it does pass. Just like before, all it’s doing it is
    ensuring that the function returns a truthy value.
  prefs: []
  type: TYPE_NORMAL
- en: That isn’t nearly complete enough, so I tried again. This time, I gave it two
    more detailed comments.
  prefs: []
  type: TYPE_NORMAL
- en: // Test getCorrelationId returns a different value each time
  prefs: []
  type: TYPE_NORMAL
- en: it('should return correlationId', () => {
  prefs: []
  type: TYPE_NORMAL
- en: const correlationId = service.getCorrelationId();
  prefs: []
  type: TYPE_NORMAL
- en: expect(service.getCorrelationId()).not.toEqual(correlationId);
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: That’s a little better. This test is ensuring that calling getCorrelationId()
    twice returns a different value. What if we call it 100 times?
  prefs: []
  type: TYPE_NORMAL
- en: // Test getCorrelationId returns a different value a bunch of times
  prefs: []
  type: TYPE_NORMAL
- en: it('should return correlationId', () => {
  prefs: []
  type: TYPE_NORMAL
- en: const correlationIds = [];
  prefs: []
  type: TYPE_NORMAL
- en: for (let i = 0; i < 100; i++) {
  prefs: []
  type: TYPE_NORMAL
- en: correlationIds.push(service.getCorrelationId());
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: expect(correlationIds.length).toEqual(100);
  prefs: []
  type: TYPE_NORMAL
- en: expect(new Set(correlationIds).size).toEqual(100);
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: That’s a much better test. This test calls getCorrelationId() 100 times and
    checks to see that all 100 results are unique.
  prefs: []
  type: TYPE_NORMAL
- en: I probably would not have thought of using a JavaScript set object to ensure
    that I never get the same value, but it’s a clever and elegant solution. Sets
    cannot contain duplicates. If the set contains 100 values after 100 iterations,
    then all the generated values were unique.
  prefs: []
  type: TYPE_NORMAL
- en: It just goes to show that Copilot works best with detailed comments.
  prefs: []
  type: TYPE_NORMAL
- en: ChatGPT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What about ChatGPT? In theory, it should be just as good at writing these tests,
    so let’s see what it gives us.
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen throughout the book, the trick to getting ChatGPT to give you
    decent code is to provide it with the right prompt. For this prompt, it’s best
    to give it the complete service implementation and ask it to write tests using
    Jasmine (or Jest if you prefer).
  prefs: []
  type: TYPE_NORMAL
- en: Given the following Angular service, write a complete suite of unit tests using
    Jasmine. <I pasted the entire class code here>
  prefs: []
  type: TYPE_NORMAL
- en: ChatGPT Responded with a complete test suite, as requested.
  prefs: []
  type: TYPE_NORMAL
- en: import { CorrelationService } from './correlation.service';
  prefs: []
  type: TYPE_NORMAL
- en: import { v4 as uuidv4 } from 'uuid';
  prefs: []
  type: TYPE_NORMAL
- en: describe('CorrelationService', () => {
  prefs: []
  type: TYPE_NORMAL
- en: 'let service: CorrelationService;'
  prefs: []
  type: TYPE_NORMAL
- en: beforeEach(() => {
  prefs: []
  type: TYPE_NORMAL
- en: service = new CorrelationService();
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: it('should create the service', () => {
  prefs: []
  type: TYPE_NORMAL
- en: expect(service).toBeTruthy();
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: describe('resetConversationId()', () => {
  prefs: []
  type: TYPE_NORMAL
- en: it('should set conversationId to a UUID', () => {
  prefs: []
  type: TYPE_NORMAL
- en: service.resetConversationId();
  prefs: []
  type: TYPE_NORMAL
- en: expect(uuidv4.test(service.conversationId)).toBe(true);
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: it('should return the new conversationId', () => {
  prefs: []
  type: TYPE_NORMAL
- en: const conversationId = service.resetConversationId();
  prefs: []
  type: TYPE_NORMAL
- en: expect(service.conversationId).toEqual(conversationId);
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: describe('getConversationId()', () => {
  prefs: []
  type: TYPE_NORMAL
- en: it('should return conversationId if set', () => {
  prefs: []
  type: TYPE_NORMAL
- en: service.conversationId = 'test-id';
  prefs: []
  type: TYPE_NORMAL
- en: expect(service.getConversationId()).toEqual('test-id');
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: it('should call resetConversationId() and return conversationId if not set',
    () => {
  prefs: []
  type: TYPE_NORMAL
- en: spyOn(service, 'resetConversationId').and.returnValue('new-id');
  prefs: []
  type: TYPE_NORMAL
- en: expect(service.getConversationId()).toEqual('new-id');
  prefs: []
  type: TYPE_NORMAL
- en: expect(service.resetConversationId).toHaveBeenCalled();
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: describe('getCorrelationId()', () => {
  prefs: []
  type: TYPE_NORMAL
- en: it('should return a UUID', () => {
  prefs: []
  type: TYPE_NORMAL
- en: const correlationId = service.getCorrelationId();
  prefs: []
  type: TYPE_NORMAL
- en: expect(uuidv4.test(correlationId)).toBe(true);
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: it('should return a different UUID each time', () => {
  prefs: []
  type: TYPE_NORMAL
- en: const correlationId1 = service.getCorrelationId();
  prefs: []
  type: TYPE_NORMAL
- en: const correlationId2 = service.getCorrelationId();
  prefs: []
  type: TYPE_NORMAL
- en: expect(correlationId1).not.toEqual(correlationId2);
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, these tests don’t even compile. While they look reasonable at
    first glance, two of the tests assume that the uuidv4 library has a test function.
  prefs: []
  type: TYPE_NORMAL
- en: expect(uuidv4.test(service.conversationId)).toBe(true);
  prefs: []
  type: TYPE_NORMAL
- en: At least the version I am using, v9, it does not.
  prefs: []
  type: TYPE_NORMAL
- en: I commented out those two tests and the rest of them passed.
  prefs: []
  type: TYPE_NORMAL
- en: What’s the takeaway here? Using Copilot may be a little more manual, but you
    have much finer control over what is being generated. With ChatGPT, you get a
    flood of code that you either have to proofread carefully or accept at face value.
  prefs: []
  type: TYPE_NORMAL
- en: I don’t recommend the latter.
  prefs: []
  type: TYPE_NORMAL
- en: Testing HTTP Calls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Testing a simple service is one thing. It’s fairly simple and the pattern is
    straightforward once you’ve done it a few times. The real value we get from AI
    is in writing tests for things that aren’t necessarily simple and straightforward,
    like testing HTTP calls.
  prefs: []
  type: TYPE_NORMAL
- en: This is something I know how to do conceptually but can never get the syntax
    right the first time. For example, I know I must import and use Angular’s HttpClientTestingModule.
    There is a certain order that things have to be called and setup that has to be
    done. And every time, it’s an exercise of trial and error until I get it right.
  prefs: []
  type: TYPE_NORMAL
- en: No longer.
  prefs: []
  type: TYPE_NORMAL
- en: I asked ChatGPT to help me write a test for a fictitious weather service. The
    service itself that I defined looks like this.
  prefs: []
  type: TYPE_NORMAL
- en: export class WeatherService {
  prefs: []
  type: TYPE_NORMAL
- en: 'http: HttpClient = inject(HttpClient);'
  prefs: []
  type: TYPE_NORMAL
- en: 'getWeather(zipcode: string) {'
  prefs: []
  type: TYPE_NORMAL
- en: return this.http.get(`weather.com/api/forecast/${zipcode}`);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: ChatGPT gave me a pretty good test suite for this one.
  prefs: []
  type: TYPE_NORMAL
- en: import { TestBed } from '@angular/core/testing';
  prefs: []
  type: TYPE_NORMAL
- en: import { HttpClientTestingModule, HttpTestingController } from '@angular/common/http/testing';
  prefs: []
  type: TYPE_NORMAL
- en: import { WeatherService } from './weather.service';
  prefs: []
  type: TYPE_NORMAL
- en: describe('WeatherService', () => {
  prefs: []
  type: TYPE_NORMAL
- en: 'let service: WeatherService;'
  prefs: []
  type: TYPE_NORMAL
- en: 'let httpMock: HttpTestingController;'
  prefs: []
  type: TYPE_NORMAL
- en: beforeEach(() => {
  prefs: []
  type: TYPE_NORMAL
- en: TestBed.configureTestingModule({
  prefs: []
  type: TYPE_NORMAL
- en: 'imports: [HttpClientTestingModule],'
  prefs: []
  type: TYPE_NORMAL
- en: 'providers: [WeatherService]'
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: service = TestBed.inject(WeatherService);
  prefs: []
  type: TYPE_NORMAL
- en: httpMock = TestBed.inject(HttpTestingController);
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: afterEach(() => {
  prefs: []
  type: TYPE_NORMAL
- en: httpMock.verify();
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: ––––––––
  prefs: []
  type: TYPE_NORMAL
- en: '![image](d2d_images/scene_break.png)'
  prefs: []
  type: TYPE_IMG
- en: it('should be created', () => {
  prefs: []
  type: TYPE_NORMAL
- en: expect(service).toBeTruthy();
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: it('should return the weather for a given zipcode', () => {
  prefs: []
  type: TYPE_NORMAL
- en: const mockResponse = {
  prefs: []
  type: TYPE_NORMAL
- en: 'temperature: 68,'
  prefs: []
  type: TYPE_NORMAL
- en: 'description: ''Sunny'''
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: const zipcode = '90210';
  prefs: []
  type: TYPE_NORMAL
- en: service.getWeather(zipcode).subscribe(response => {
  prefs: []
  type: TYPE_NORMAL
- en: expect(response).toEqual(mockResponse);
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: const request = httpMock.expectOne(`weather.com/api/forecast/${zipcode}`);
  prefs: []
  type: TYPE_NORMAL
- en: expect(request.request.method).toBe('GET');
  prefs: []
  type: TYPE_NORMAL
- en: request.flush(mockResponse);
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: It only handled the “happy path,” but it gave me the structure I was looking
    for. As I implied, testing Angular’s HttpClient is finicky, and I typically get
    it wrong the first time.
  prefs: []
  type: TYPE_NORMAL
- en: For some reason, I can never seem to remember to include the verification in
    afterEach, which assures that the service only made the expected HTTP calls, no
    more or less. Nor do I tend to remember the right order to create the mock’s expectOne
    and flush functions.
  prefs: []
  type: TYPE_NORMAL
- en: Having ChatGPT build this test suite for me saves a lot of time. Once I have
    the structure in place, I can fill in the gaps (or get Copilot to do it for me).
  prefs: []
  type: TYPE_NORMAL
- en: This test passed the first time, by the way.
  prefs: []
  type: TYPE_NORMAL
- en: Far From Perfect
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s not all wine and roses, to be sure. We have already seen that ChatGPT doesn’t
    know anything past mid-2021 or so. Copilot is better in this regard, as it is
    trained on almost all of GitHub, plus it can see your code.
  prefs: []
  type: TYPE_NORMAL
- en: I tried to get each of them to help me write a unit test for an Angular HttpInterceptor,
    to use with the CorrelationService from the beginning of the chapter. I use an
    interceptor to add the correlationId and coversationId values as HTTP headers
    on every outgoing HTTP call.
  prefs: []
  type: TYPE_NORMAL
- en: ChatGPT knew about the class based HttpInterceptor, but nothing about the new
    functional HttpInterceptorFn, which was just introduced in Angular 15\. Predictably,
    ChatGPT knew nothing about it, insisting that no such thing exists.
  prefs: []
  type: TYPE_NORMAL
- en: Copilot tried but gave me nothing I could use. The results are not even worth
    reproducing here.
  prefs: []
  type: TYPE_NORMAL
- en: Undoubtedly things will get better. For now, consider this one more piece of
    evidence that as good as the AI gets, we software developers still need to understand
    our craft. We can use these tools to help us, but we always need to be aware of
    their limitations.
  prefs: []
  type: TYPE_NORMAL
