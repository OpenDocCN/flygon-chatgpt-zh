



# 正则表达式



![在黑板上指导学生的教师](img/image018.jpg)

作者和 OpenAI 提供的图片

输入验证是确保数据完整性和防止安全漏洞的关键组成部分。然而，制作有效的正则表达式（regexes）可能是一项耗时且具有挑战性的任务。这就是 Copilot 和 ChatGPT 发挥作用的地方。在本章中，我着手探索它们如何仅仅通过一个简单的提示来生成用于输入验证的正则表达式，并发现了这种基于人工智能的工具的惊人有效性。继续阅读，了解我的发现以及这种工具的惊人有效性。

## 正则表达式 101 网站

我决定使用现有的正则表达式网站来帮助我测试 Copilot 提供的内容：[regex101: 构建、测试和调试正则表达式](https://regex101.com/)。 ([`regex101.com`](https://regex101.com))

这个网站让我选择要测试的正则表达式类型，并具有一些非常酷的错误检测和调试功能。

### 电子邮件地址

我首先想到的是评估一个字符串是否是有效的电子邮件地址。

我让 Copilot 在一个 TypeScript 文件中为我创建一个电子邮件模式。这就是它给我的东西。

// 电子邮件正则表达式

emailRegex = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;

它看起来很聪明，但它有效吗？将其放入[regex101.com](http://regex101.com/)，我能够相对快速地测试一些电子邮件。以下是我尝试过的一些其他电子邮件地址：

### 匹配

mike@company.com

mike@company.co.uk

x@y.com

mike@x.cc

### 未匹配

mike@localhost

mike@10.0.0.1

mike@x.

比尔

前两个是有效的，但 Copilot 的正则表达式未能匹配它们。ChatGPT 会做得更好吗？

给我一个验证电子邮件地址的正则表达式

^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$

这个看起来与 Copilot 给我的完全不同。它在我的测试电子邮件地址上表现如何？事实证明，它完全匹配。ChatGPT 为我提供了关于它给我的正则表达式的详细解释，我不会在这里重复。可以说它是完整的。

所以，它们并不差，但我想知道它们与专业人士相比如何。

根据我在[一篇关于最全面电子邮件正则表达式的文章](https://www.abstractapi.com/guides/email-address-pattern-validation)中找到的内容，这是“最佳”的电子邮件模式：

([-!#-'*+/-9=?A-Z^-~]+(\.[-!#-'*+/-9=?A-Z^-~]+)*|"([]!#-[^-~ \t]|(\\[\t -~]))+")@(0-9A-Za-z?(\.0-9A-Za-z?)*|\[((25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])(\.(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])){3}|IPv6:((((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){6}|::((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){5}|[0-9A-Fa-f]{0,4}::((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){4}|(((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):)?(0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}))?::((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){3}|(((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){0,2}(0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}))?::((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){2}|(((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){0,3}(0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}))?::(0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):|(((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){0,4}(0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}))?::)((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):(0|[1-9A-Fa-f][0-9A-Fa-f]{0,3})|(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])(\.(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])){3})|(((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){0,5}(0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}))?::(0|[1-9A-Fa-f][0-9A-Fa-f]{0,3})|(((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){0,6}(0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}))?::)|(?!IPv6:)[0-9A-Za-z-]*[0-9A-Za-z]:[!-Z^-~]+)])

那是一个 1240 个字符的正则表达式！看起来与 AI 给我的那个完全不同。

这个做得更好，包括匹配上述列表中第一个正则表达式未能匹配的两个有效电子邮件地址。

mike@localhost

mike@10.0.0.1

老实说，我认为 AI 的两个正则表达式都不错，但它们确实漏掉了那两个有效的电子邮件地址。

### 电话号码

接下来，它们在验证电话号码方面表现如何？我给 Copilot 一个评论提示，看看它能给我什么，起初它给了我这个。

// 带有可选国家代码的电话号码模式

phoneRegex = /^(\+?1)?[2-9]\d{2}2-9\d{6}$/;

这个有点用，但不允许号码中有任何标点或空格。它允许一个可选的 +1，但这只适用于美国电话号码。

### 匹配

2025551212

8002822882

+12025551212

+14079393463

### 未匹配

603–555–1212

603 555 1212

(603) 555 1212

尽管还没有完全泄气，我想我会再试一次。我给了它一个不同的评论：

// 国际电话号码

phoneRegex = /^\+?([0-9]{2})\)?[-. ]?([0-9]{3})[-. ]?([0-9]{3})[-. ]?([0-9]{4})$/;

这个更加灵活，但仍然无法匹配我认为一些常见电话号码格式：

### 匹配

+01 202 555 1212

+014079393463

// 英国号码

+44 889 234 1239

+44.889.234.1239

+44 889–234–1239

### 未匹配

(202) 555–1212

800–282–2882

到目前为止，我对 Copilot 给我的东西并不满意。ChatGPT 给了我这个：

给我一个可以验证任何电话号码，美国或国际的正则表达式，宽松接受常见标点符号。

^[\+]?[\d]{0,3}[\s.-]?[\(]?[\d]{1,3}[\)]?[\s.-]?[\d]{3,4}[\s.-]?[\d]{3,4}$

实际上效果更差，只匹配了前两个英国数字，并且无法匹配 Copilot 模式的同样内容。也许用正则表达式匹配电话号码太困难了。

### 有效的 URL

虽然与验证无关，但我想知道 Copilot 是否会给我一个识别字符串中所有有效 URL 的模式。这对于爬取网站可能会有用。和其他例子一样，我先写了一个注释。它给了我两个选项：

// 用于在字符串中找到 URL 的正则表达式

urlRegex = /((https?:\/\/)|(www\.))[^\s]+/g;

urlRegex = /((https?:\/\/)?[\w-]+(\.[\w-]+)+\.?(:\d+)?(\/\S*)?)/g;

我觉得这些建议真的很酷的地方在于 Copilot 在两个正则表达式上都给了我“g”修饰符（全局匹配），可能是因为我在评论中要求“URLs”（复数），而不是单一的“URL”。

第一个，虽然乍一看还行，但是完全错了。我的测试字符串是带有大量链接的网页源代码。第一个正则表达式给了我 137 个匹配项，但经进一步检查，它包含了周围文本的标点符号，而不是 URL 的一部分。

因此，我决定尝试第二个更长的建议。那个实际上更糟糕，匹配了一堆明显不是 URL 的文本。我对这两个正则表达式的困扰之处在于它们匹配了 HTML 属性中的引号。

<img src="https://pictures.com/images/12345.jpg">

根据这两个正则表达式，该 img 标签的 URL 部分是 https://pictures.com/images/12345.jpg"

使我觉得也许我的评论提示错了。我不是在“字符串”中搜索 URL，也许我应该更具体一点。我决定再试一次。

// 用于从 img 和 a 标签中找到所有 URL 的正则表达式

urlRegex = /<img[^>]*src="([^"]*)"[^>]*>|<a[^>]*href="([^"]*)"[^>]*>/g;

有趣的是，我认为这个最接近。请注意，我的评论对我正在寻找的东西更加具体。更重要的是，我需要仔细检查匹配项。实际的 URL 在每个匹配的第二组中。

ChatGPT 一直以来都取得了一些研究和实验的成果。

给我一个正则表达式，从 HTML 页面的文本中找到所有 img 和 a 标签的 URL。

(?<=<img.*?src="|<a.*?href=")[^"]*

它没有给我一个匹配 URL 的正则表达式。实际上，这是一个提取跟在 img 或 href 属性后引号中完整字符串的正则表达式。这其实就是我要求的。

迳然没有放弃，我向 ChatGPT 明确表示以调整其理解。

给我一个匹配在文本文档中找到的 URL 的正则表达式，这些文档可能是 HTML 格式，也可能不是。

\b(?:(?:https?|ftp):\/\/|www\.)[^\s]+\b

它的解释是全面的，所以我测试了一下，发现它无疑是最好的正则表达式。如果你要验证给定的字符串是否确实是 URL，这将是更好的正则表达式。

### 密码复杂性

几乎每个允许用户注册的网站都有一些关于密码复杂性的规则。Can Copilot 生成一个正则表达式来验证这样的密码吗？

// 密码必须包含至少一个数字，一个小写字母和一个大写字母，一个符号，并且至少为 8 个字符长。

private passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[^\da-zA-Z]).{8,}$/;

那真是一个正则表达式，但它正确吗？我转到 regex101.com，对它进行了测试。

### 有效的密码

P@55word

This1s@GoodPassword

MikeWasHerein1999!

### 无效的密码

密码

MikeWasHere!

这是一个糟糕的密码

12345

我草率地认为这是一个很好用途的正则表达式。

ChatGPT 给了我一个功能上类似但稍有不同的模式。

给我一个正则表达式，用以下规则验证密码复杂性：密码必须包含至少一个数字，一个小写字母和一个大写字母，一个符号，并且至少为 8 个字符长。

^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?=.*\W)[\S]{8,}$

它与 Copilot 的正则表达式匹配了同样的密码列表，所以我认为它们都是有效的。

### 有效的美元货币

另一个常见的情况是确定输入是否是有效的美国货币。

// 验证输入是否是美国货币

private currencyRegex = /^\$?(([1-9]\d{0,2}(,\d{3})*)|0)?(\.\d{2})?$/;

这个乍一看看起来不错。我尝试了一小部分字符串列表，我想像人们可能会在网页上输入的货币。让我们看看那个正则表达式的效果。

### 有效的货币

$1

.22

$.25

0.79

1.49

$0.00

$0.43

$1,230,847,369.99

### 无效的货币

Mike

1.575

1.57$

2.25%

1 美元

看起来对我来说相当不错。我会认为这是一个通过。

ChatGPT 给了我一个相似的正则表达式。

给我一个正则表达式，用来验证输入是否是美国货币

^\$[1-9]\d{0,2}(,\d{3})*(\.\d{2})?$

不幸的是，它没有通过所有测试值，除了第一个和最后一个有效值。我让它再试一次，允许一个可选的美元符号。它给我的正则表达式只能验证一种额外的测试值 (1.49)，但在剩下的上面仍然失败了。

再给它一次机会，我决定采取一种不同的方法。这是我整个对话及其回复。

给出一个可能的写法列表，写一个可以匹配所有这些的正则表达式：$1 .22 $.25 0.79 1.49 $0.00 $0.43 $1,230,847,369.99

这里是一个可以匹配所有给出的美国货币值示例的正则表达式：

^(?:\$\s?)?(?:\d{1,3}(?:,\d{3})*|\d+)(?:\.\d{2})?$

让我们分解这个正则表达式：

^ - 起始位置

(?:\$\s?)? - 可选择地匹配一个美元符号后面跟着一个可选的空白字符

(?:\d{1,3}(?:,\d{3})*|\d+) - 匹配 1-3 位数字序列，可选择地跟着逗号分隔的三位数字组，或一个或多个数字的单个序列。

(?:\.\d{2})? - 可选择地匹配一个小数点后面跟着精确两位数字

$ - 行结束

此正则表达式匹配给定示例的美元金额，包括带有或不带有美元符号、小数点和逗号的金额。

请注意，此正则表达式不匹配负金额。此外，如果您有具有不寻常格式的货币值，例如负金额或小数点后超过两位的金额，则可能需要相应修改正则表达式。

你认为它表现如何？

它获取了所有内容，除了$0.25 的值。还不错，但这表明 ChatGPT 并非万无一失。但是，我很欣赏给它示例并让它完成其余工作的力量。

### 美国社会安全号码

那么社会安全号码呢？在美国，这些都很简单，所以我对此并没有期望太高。

// 验证输入是否为有效的社会安全号码

private ssnRegex = /^\d{3}-?\d{2}-?\d{4}$/;

#### 有效的社会安全号码

999–99–9999

012–34–5678

978–76–5432

#### 无效的社会安全号码

978 76 5432

97–876–5432

5432–76–978

xxx-yy-zzzz

正如我所说，非常直接。ChatGPT 在回复中做得更多。

编写一个正则表达式，用于验证输入是否为有效的社会安全号码。

^(?!000)(?!666)[0-8]\d{2}[- ]?(?!00)\d{2}[- ]?(?!0000)\d{4}$

此正则表达式确保特定的社会安全号码被明确禁止。ChatGPT 还提供了这个警告，我觉得既有用又有趣。

请注意，此正则表达式仅检查 SSN 的格式，而不检查它是否是分配给特定人员的实际有效 SSN。值得注意的是，一些在 2011 年 6 月 25 日之前分配的 SSN 可能无效，因为社会安全管理局在该日期实施了新的随机化政策。

我不知道关于社会安全号码的这些琐事。

### 有效的信用卡号

我预计这个可能会更具挑战性。验证信用卡号是 Web 应用程序的常见任务。然而，仅依赖正则表达式（regex）来验证信用卡号可能是危险的。虽然正则表达式是用于模式匹配的强大工具，但它可能无法捕捉与信用卡号相关的所有潜在错误或安全风险。

这是因为信用卡号具有多个规则和限制的复杂结构，正则表达式模式可能并不总是考虑到所有这些规则。信用卡号不仅仅是一组分组的数字模式，尽管乍一看可能是这样。我不认为正则表达式可以计算校验和（也称为[卢恩算法](https://www.creditcardvalidator.org/developer)），所以我认为我们可能只能“接近”。

// 验证信用卡号码

private creditCardRegex = /^((4\d{3})|(5[1-5]\d{2})|(6011))(-?\d{4}){3}$/;

那个正则表达式可能适用于首次客户端验证，但远非完美。

#### 有效的信用卡号

4321567843215678

6011222233334444

4444333322221111

5432123456789999

#### 无效的信用卡号

4321 5678 4321 5678

6011 2222 3333 4444

4444 3333 2222 1111

5432 1234 5678 9999

378282246310005（有效的 Amex）

最后一个是假阴性。显然，正则表达式无法匹配美国运通卡号。

我最后的想法是 Copilot 是否知道 Lunh 算法是什么。我上面链接的开发者页面上有 JavaScript 代码。

当我输入我的评论时，我得到了这个回复，这不是我预期的：

// 使用 Lunh 算法验证信用卡号

private creditCardLuhnRegex = /^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|6(?:011|5[0-9][0-9])[0-9]{12}|(?:2131|1800|35\d{3})\d{11})$/;

它实际上似乎没有实现该算法，但它确实匹配了第一个正则表达式错过的美国运通卡号。

在离开这一部分之前，我想知道对我的评论稍作修改是否会起作用。

// 使用 Lunh 算法验证信用卡号的函数

private validateCreditCardNumber(cardNumber: string): boolean {

let sum = 0;

let shouldDouble = false;

for (let i = cardNumber.length - 1; i >= 0; i—) {

let digit = parseInt(cardNumber.charAt(i), 10);

if (shouldDouble) {

if ((digit *= 2) > 9) digit -= 9;

}

sum += digit;

shouldDouble = !shouldDouble;

}

return sum % 10 === 0;

} // 结束 validateCreditCardNumber

我没有运行它来测试，但这更接近我预期的结果。随时尝试一下。

我怀疑 ChatGPT 在这方面会更好，所以我给了它一个类似的提示，看看它会得出什么。

实现一个使用 Lunh 算法验证信用卡号的函数

当然，这里有一个使用 Luhn 算法验证信用卡号的 Python 函数：

def validate_credit_card_number(card_number):

# 反转信用卡号并将每个数字转换为整数

digits = [int(x) for x in str(card_number)][::-1]

# 将每第二个数字的值加倍

doubled_digits = []

for i, digit in enumerate(digits):

if i % 2 == 1:

doubled_digits.append(digit * 2)

else:

doubled_digits.append(digit)

# 将加倍值的数字和未加倍的数字相加

total = 0

for digit in doubled_digits:

if digit > 9:

total += digit - 9

else:

total += digit

# 如果总和是 10 的倍数，则信用卡号有效

return total % 10 == 0

它有效吗？我不太清楚。老实说，我没有测试过。我不会说 Python，但它让我一窥 ChatGPT（和可能是 Copilot）了解的一些语言。我从 Copilot 得到的 JavaScript 代码与网站上的 JavaScript 代码看起来不同。

如果你决定测试任一版本，请告诉我它是否有效。

### HTML 标签

Copilot 能识别合法的 HTML 标签吗？

// 识别输入文本中的所有 HTML 标签

private htmlTagRegex = /<[^>]*>/g;

我不会在这里展示匹配结果，但这个似乎有效。我唯一的抱怨是它也看到了闭合标签。

ChatGPT 认为我仍然想要 Python，基于我上次与它的对话。这是另一个提醒，你的对话有 ChatGPT 会记住的上下文。

编写一个正则表达式来识别输入文本中的所有 HTML 标签。

import re

模式 = r'<\/?[a-zA-Z]+\b(?:\s*[a-zA-Z]+=(?:"[^"]*"|\'[^\']*\'))*\s*\/?>'

tags = re.findall(pattern, input_text)

回到给我原始正则表达式，不要包裹在 Python 中

<\/?[a-zA-Z]+\b(?:\s*[a-zA-Z]+=(?:"[^"]*"|\'[^\']*\'))*\s*\/?>

它们似乎是相同的正则表达式，只是前者包含了 Python 语法。

### 检测重复单词

在一段文本中检测重复单词有多难？

// 在输入文本中查找重复的单词

private repeatedWordRegex = /\b(\w+)\b\s+\b\1\b/g;

我本以为这个会比实际复杂，但反思之后，这正是正则表达式擅长的事情。ChatGPT 给出的模式几乎完全相同，只是似乎考虑了被标点符号分隔的重复单词。

\b(\w+)\b(?=.*\b\1\b)

请注意，这个正则表达式不会匹配被非单词字符分隔的重复单词（例如，“hello, hello”不会匹配）。如果你想匹配无论分隔它们的字符是什么的重复单词，你可以在正则表达式中用空格字符\s 替换单词边界\b。

#### 检测到重复单词

迈克曾在此处留下痕迹

敏捷的棕色狐狸跳过了懒狗

空格，最终的边界

#### 未检测到重复单词

迈克曾在此处

迈克曾在此处留下痕迹

空格，最终的边界

敏捷的棕色狐狸跳过了懒狗

你可能注意到正则表达式是区分大小写的。添加一个 i 应该可以解决这个问题。

### 有效的 JavaScript 标识符

在我看到它写的内容后，这个我才明白，但这不是我期望的（老实说，我不确定我期望什么）。

// 识别输入文本中的所有有效 JavaScript 关键字

private jsKeywordRegex = /\b(break|case|catch|continue|debugger|default|delete|do|else|finally|for|function|if|in|instanceof|new|return|switch|this|throw|try|typeof|var|void|while|with|class|const|enum|export|extends|import|super|implements|interface|let|package|private|protected|public|static|yield|abstract|boolean|byte|char|double|final|float|goto|int|long|native|short|synchronized|throws|transient|volatile)\b/g;

ChatGPT 给出的实际上是几乎相同的正则表达式。

\b(?:await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|false|finally|for|function|if|implements|import|in|instanceof|interface|let|new|null|package|private|protected|public|return|super|switch|this|throw|true|try|typeof|var|void|while|with|yield)\b

更仔细地查看这两个模式，我并不确信它们两者都是 100%正确的。

### 结论

在一些早期的失败之后，我认为可以肯定地说，ChatGPT 和 Copilot 都可以帮助处理正则表达式。然而，正如你所看到的，它们都远非完美。

就像任何由 AI（甚至其他开发人员）为你编写的代码一样，你不能简单地不加怀疑地接受所给出的代码。理解代码的功能是很重要的。

正如我之前所写的，我会在合适的情况下继续使用它们。不过，我不会盲目地使用由人工智能为我写的一切。
